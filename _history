{"entries":[{"timestamp":1756402185141,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":351,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":48,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":174,"length1":47,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":203,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"bytescript.ts","value":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {};\n        let i = 0;\n\n        while (i < lines.length-1) {\n            let line = lines[i];\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break;\n            }\n            i++; // INCREMENT.\n        }\n    }\n    function handle(a:any,b:any) {\n        if (!!b[a]) {\n            return b[a];\n        } else {\n            return a;\n        }\n    }\n}"}]},{"timestamp":1756402798382,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.ts","patch":[{"start1":269,"length1":34,"diffs":[[1,"            let line = lines[i];\n"]]}]}]},{"timestamp":1756402811020,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":108,"diffs":[[1,"bytescript.runCode({code:\"PRINT 10 \\n GOTO 0\"})\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":197,"length1":58,"diffs":[[1,"        \"bytescript.ts\"\n"]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":168,"length1":64,"diffs":[[1,"        let vars:{[index:string]:any} = {};\n"]]},{"start1":232,"length1":85,"diffs":[[1,"        while (i < lines.length-1) {\n            let line = lines[i] ;\n"]]},{"start1":693,"length1":491,"diffs":[[1,"                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break;\n"]]},{"start1":847,"length1":19,"diffs":[[1,""]]}]},{"type":"added","filename":"bytescript.compiler.ts","value":"/**\n * interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n\n        while (i < lines.length) {\n            let line = lines[i].trim() || \"HALT\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a:any,b:any) {\n        if (!!b[a]) {\n            return b[a];\n        } else {\n            return a;\n        }\n    }\n}\n */\nnamespace bytescript {\n    export function compileCode(c:ByteScript) {}\n}"}]},{"timestamp":1756403324921,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":1471,"length1":53,"diffs":[[1,"    export function compileCode(c:ByteScript) {}\n"]]}]}]},{"timestamp":1756404823250,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":1471,"length1":61,"diffs":[[1,"    export function compileCode(c:ByteScript) {}    \n"]]}]}]},{"timestamp":1756404833738,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":67,"length1":102,"diffs":[[1,"        \"device\": \"*\"\n"]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":1471,"length1":1771,"diffs":[[1,"    export function compileCode(c:ByteScript):ByteCod {}    \n"]]}]}]},{"timestamp":1756405433596,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":108,"length1":124,"diffs":[[1,""]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":1583,"length1":57,"diffs":[[1,"        bytecode:number[];\n        type:BYTECODE_TYPE;\n"]]},{"start1":1672,"length1":38,"diffs":[[1,"        private _nums:number[] = [];\n"]]},{"start1":1810,"length1":1125,"diffs":[[1,"        addGOTO(address:number) {}\n        addADD(varaddress:number,v:number) {}\n        addSUB(varaddress: number, v: number) { }\n        addVAR(varaddress: number, v: number) { }\n        addHALT() { }\n        addGOTO_IF_ZERO(varaddress:number,v:number) {}\n        addGOTO_IF_NOT_ZERO(varaddress: number, v: number) { }\n"]]},{"start1":2137,"length1":100,"diffs":[[1,"    export function compileCode(c:ByteScript):ByteCode {\n"]]},{"start1":2233,"length1":48,"diffs":[[1,"        let varmap = new Map<string,number>();\n"]]},{"start1":2324,"length1":43,"diffs":[[1,""]]},{"start1":2512,"length1":392,"diffs":[[1,"                case \"ADD\": curr.addADD(map(parts[1],varmap),parseInt(parts[2])); break; // ADD A 4\n                case \"SUB\": curr.addSUB(map(parta[1],varmap),parseInt(parts[2])); break; // SUB A 8\n                case \"VAR\":curr.addVAR(null,parseInt(parts[2])); break; // VAR A 2\n                case \"PRINT\": break;\n"]]},{"start1":2877,"length1":372,"diffs":[[1,"                case \"GOTO_IF_ZERO\": curr.addGOTO_IF_ZERO(null,parseInt(parts[2])); break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": curr.addGOTO_IF_NOT_ZERO(null,parseInt(parts[2])); break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n"]]},{"start1":3173,"length1":440,"diffs":[[1,"        return {bytecode:[],type:BYTESCRIPT_BYTECODE_SIG};\n    }    \n"]]}]}]},{"timestamp":1756406031653,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":108,"length1":158,"diffs":[[1,"let bytecode = bytescript.compileCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })"]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":1504,"length1":53,"diffs":[[1,"    export const BYTESCRIPT_BYTECODE_SIG = 564836583;\n"]]},{"start1":1879,"length1":108,"diffs":[[1,"            this._nums.push(address & 0xFF00);\n            this._nums.push(address & 0x00FF);\n"]]},{"start1":3252,"length1":85,"diffs":[[1,"            let parts = line.split(\" \")\n"]]},{"start1":3324,"length1":178,"diffs":[[1,"                case \"GOTO\": curr.addGOTO(parseInt(parts[1])); break; // GOTO 800\n"]]},{"start1":4151,"length1":93,"diffs":[[1,"                default:console.log(\"Build Warning: Command\" +)\n"]]}]}]},{"timestamp":1756406627671,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":108,"length1":230,"diffs":[[1,"let bytecode = bytescript.compileCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 5920\" })\nconsole.log(bytecode.bytecode)"]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":1218,"length1":341,"diffs":[[1,""]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":3382,"length1":220,"diffs":[[1,"                case \"GOTO\": let addr = parseInt(parts[1]);if (addr < 0 || addr > lines.length-1) {console.log(\"Build Error:\");break;};curr.addGOTO(addr * 3); break; // GOTO 800\n"]]},{"start1":4305,"length1":107,"diffs":[[1,""]]}]}]},{"timestamp":1756407221700,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.ts","patch":[{"start1":1218,"length1":539,"diffs":[[1,"                case \"MEM_STORE\": break; // emularion not doable in running. , but not compling. reason: this interfaceswith a specficvaribles address which is the low-leve repsnrentaion of a varible name , example:A = 1 , HELLO_WORLD_THIS_IS_A_SUPER_LONG_VAR_NAME = 2 , note: no longer howl ong th var nam is , the var address is always...\n"]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":2951,"length1":319,"diffs":[[1,""]]},{"start1":4454,"length1":180,"diffs":[[1,""]]},{"start1":4787,"length1":152,"diffs":[[1,"            map.set(varName, map.valuesArray().length == 0 ? 1 : map.valuesArray()[map.valuesArray().length - 1]++); // if it does not exist , make it.\n"]]},{"start1":4949,"length1":111,"diffs":[[1,"        return map.get(varName); // in any case get it.\n"]]}]}]},{"timestamp":1756407821003,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":1187,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"bytescript.runCode({code:&quot;PRINT 10 \\n GOTO 0&quot;})\" numlines=\"1\"></mutation></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":272,"length1":70,"diffs":[[1,"console.log(\"Starting Execute...\")\nbytescript.runCode({code:prog})"]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":1471,"length1":32,"diffs":[[1,""]]},{"start1":5070,"length1":268,"diffs":[[1,"        console.log(\"Build Completed.\")\n"]]},{"start1":5486,"length1":135,"diffs":[[1,"        return val > 255 ? console.log(\"\") : val; // in any case get it.\n"]]}]}]},{"timestamp":1756408420249,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":5102,"length1":370,"diffs":[[1,"        console.log(`Build Completed, Build Info: Varibles Used ${varmap.valuesArray().length}/256, ROM used:${Math.roundWithPrecision(((curr.bytecode.length / 1024) / USE_#) * 100, 4)}% or in alternate format:${lines.length}/${USE_32KB_ROM ? \"32, 768\"} Lines Used.`)\n"]]}]}]},{"timestamp":1756410200440,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"/**\n * interface ByteScript {\n    code:string;\n    name?:string;\n}\n"]]},{"start1":91,"length1":0,"diffs":[[1,"    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n\n        while (i < lines.length) {\n            let line = lines[i].trim() || \"HALT\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a:any,b:any) {\n        if (!!b[a]) {\n            return b[a];\n        } else {\n            return a;\n        }\n    }\n}\n */\nnamespace bytescript {\n"]]}]}]},{"timestamp":1756410209690,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":1033,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"const prog = `\" line1=\"VAR A 20\" line2=\"SUB A 1\" line3=\"GOTO_IF_NOT_ZERO A 1\" line4=\"PRINT COMPLETED PROGRAM\" line5=\"`\" numlines=\"6\" declaredvars=\"prog\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let bytecode = bytescript.compileCode({ code: prog })\" numlines=\"1\" declaredvars=\"bytecode\"></mutation><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">bytecode.bytecode</field></block></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\">Starting Execute...</field></shadow></value><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"bytescript.runCode({code:prog})\" numlines=\"1\"></mutation></block></next></block></next></block></next></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":1757,"length1":110,"diffs":[[1,""]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":0,"length1":36,"diffs":[[1,"\n"]]},{"start1":89,"length1":47,"diffs":[[1,""]]},{"start1":230,"length1":34,"diffs":[[1,""]]},{"start1":1855,"length1":760,"diffs":[[1,""]]},{"start1":3538,"length1":72,"diffs":[[1,""]]},{"start1":3655,"length1":382,"diffs":[[1,"        console.log(`Build Completed, Build Info: Varibles Used ${varmap.valuesArray().length}/256, ROM used:${Math.roundWithPrecision(((curr.bytecode.length / 1024) / (USE_32KB_ROM ? 32 : 4)) * 100, 4)}% or in alternate format:${lines.length}/${USE_32KB_ROM ? \"10,922\" : \"1,365\"} Lines Used. , Asummptions for Size Caluctions: ROM is ${USE_32KB_ROM ? \"32KB\" : \"4KB\"}`)\n"]]}]}]},{"timestamp":1756410716931,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":123,"length1":11,"diffs":[[1,"VAR A 20\nSUB A 1\nGOTO_IF_NOT_ZERO A 1\nPRINT COMPLETED PROGRAM\n"]]},{"start1":187,"length1":155,"diffs":[[1,"let bytecode = bytescript.compileCode({ code: prog })\nconsole.log(bytecode.bytecode)\n//console.log(\"Starting Execute...\")\n//bytescript.runCode({code:prog})"]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":287,"length1":49,"diffs":[[1,"            let line = lines[i].trim() || \"HALT\";\n"]]},{"start1":1867,"length1":34,"diffs":[[1,""]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":2731,"length1":122,"diffs":[[1,""]]},{"start1":4486,"length1":49,"diffs":[[1,""]]}]}]},{"timestamp":1756411392332,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":67,"length1":22,"diffs":[[1,"        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n"]]}]}]},{"timestamp":1756411771403,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":123,"length1":403,"diffs":[[1,"PRINT HEYA\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":67,"length1":102,"diffs":[[1,"        \"device\": \"*\"\n"]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":287,"length1":63,"diffs":[[1,"            let line = lines[i].trim() || \"NOP\";\n"]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":3198,"length1":39,"diffs":[[1,""]]}]}]},{"timestamp":1756412352160,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":528,"length1":2634,"diffs":[[1,"//let bytecode = bytescript.compileCode({ code: prog })\n//console.log(bytecode.bytecode)\nconsole.log(\"Starting Execute...\")\nbytescript.runCode({code:prog})"]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":84,"length1":73,"diffs":[[1,""]]},{"start1":423,"length1":77,"diffs":[[1,"                case \"GOTO\": i = parseInt(parts[1]) - 1; break; // GOTO 800\n"]]},{"start1":944,"length1":289,"diffs":[[1,"                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n"]]},{"start1":1622,"length1":150,"diffs":[[1,"                case \"SHR\": vars[parts[1]] >>= parseInt(parts[2]); break;\n                case \"SHL\": vars[parts[1]] <<= parseInt(parts[2]); break;\n"]]},{"start1":1914,"length1":81,"diffs":[[1,""]]},{"start1":1994,"length1":158,"diffs":[[1,"    function handle(a:any,b:any) {\n        if (!!b[a]) {\n            return b[a];\n"]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":4803,"length1":96,"diffs":[[1,""]]}]}]},{"timestamp":1756412970054,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":4856,"length1":27,"diffs":[[1,"                return null;\n"]]}]}]},{"timestamp":1756412979591,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":528,"length1":54,"diffs":[[1,"const prog2 = `\nVAR 0 0\nVAR 1 0\nVAR 2 0\nVAR 3 0\nVAR 4 0\nVAR 5 0\nVAR 6 0\nVAR 7 0\nVAR 8 0\nVAR 9 0\nVAR 10 0\nVAR 11 0\nVAR 12 0\nVAR 13 0\nVAR 14 0\nVAR 15 0\nVAR 16 0\nVAR 17 0\nVAR 18 0\nVAR 19 0\nVAR 20 0\nVAR 21 0\nVAR 22 0\nVAR 23 0\nVAR 24 0\nVAR 25 0\nVAR 26 0\nVAR 27 0\nVAR 28 0\nVAR 29 0\nVAR 30 0\nVAR 31 0\nVAR 32 0\nVAR 33 0\nVAR 34 0\nVAR 35 0\nVAR 36 0\nVAR 37 0\nVAR 38 0\nVAR 39 0\nVAR 40 0\nVAR 41 0\nVAR 42 0\nVAR 43 0\nVAR 44 0\nVAR 45 0\nVAR 46 0\nVAR 47 0\nVAR 48 0\nVAR 49 0\nVAR 50 0\nVAR 51 0\nVAR 52 0\nVAR 53 0\nVAR 54 0\nVAR 55 0\nVAR 56 0\nVAR 57 0\nVAR 58 0\nVAR 59 0\nVAR 60 0\nVAR 61 0\nVAR 62 0\nVAR 63 0\nVAR 64 0\nVAR 65 0\nVAR 66 0\nVAR 67 0\nVAR 68 0\nVAR 69 0\nVAR 70 0\nVAR 71 0\nVAR 72 0\nVAR 73 0\nVAR 74 0\nVAR 75 0\nVAR 76 0\nVAR 77 0\nVAR 78 0\nVAR 79 0\nVAR 80 0\nVAR 81 0\nVAR 82 0\nVAR 83 0\nVAR 84 0\nVAR 85 0\nVAR 86 0\nVAR 87 0\nVAR 88 0\nVAR 89 0\nVAR 90 0\nVAR 91 0\nVAR 92 0\nVAR 93 0\nVAR 94 0\nVAR 95 0\nVAR 96 0\nVAR 97 0\nVAR 98 0\nVAR 99 0\nVAR 100 0\nVAR 101 0\nVAR 102 0\nVAR 103 0\nVAR 104 0\nVAR 105 0\nVAR 106 0\nVAR 107 0\nVAR 108 0\nVAR 109 0\nVAR 110 0\nVAR 111 0\nVAR 112 0\nVAR 113 0\nVAR 114 0\nVAR 115 0\nVAR 116 0\nVAR 117 0\nVAR 118 0\nVAR 119 0\nVAR 120 0\nVAR 121 0\nVAR 122 0\nVAR 123 0\nVAR 124 0\nVAR 125 0\nVAR 126 0\nVAR 127 0\nVAR 128 0\nVAR 129 0\nVAR 130 0\nVAR 131 0\nVAR 132 0\nVAR 133 0\nVAR 134 0\nVAR 135 0\nVAR 136 0\nVAR 137 0\nVAR 138 0\nVAR 139 0\nVAR 140 0\nVAR 141 0\nVAR 142 0\nVAR 143 0\nVAR 144 0\nVAR 145 0\nVAR 146 0\nVAR 147 0\nVAR 148 0\nVAR 149 0\nVAR 150 0\nVAR 151 0\nVAR 152 0\nVAR 153 0\nVAR 154 0\nVAR 155 0\nVAR 156 0\nVAR 157 0\nVAR 158 0\nVAR 159 0\nVAR 160 0\nVAR 161 0\nVAR 162 0\nVAR 163 0\nVAR 164 0\nVAR 165 0\nVAR 166 0\nVAR 167 0\nVAR 168 0\nVAR 169 0\nVAR 170 0\nVAR 171 0\nVAR 172 0\nVAR 173 0\nVAR 174 0\nVAR 175 0\nVAR 176 0\nVAR 177 0\nVAR 178 0\nVAR 179 0\nVAR 180 0\nVAR 181 0\nVAR 182 0\nVAR 183 0\nVAR 184 0\nVAR 185 0\nVAR 186 0\nVAR 187 0\nVAR 188 0\nVAR 189 0\nVAR 190 0\nVAR 191 0\nVAR 192 0\nVAR 193 0\nVAR 194 0\nVAR 195 0\nVAR 196 0\nVAR 197 0\nVAR 198 0\nVAR 199 0\nVAR 200 0\nVAR 201 0\nVAR 202 0\nVAR 203 0\nVAR 204 0\nVAR 205 0\nVAR 206 0\nVAR 207 0\nVAR 208 0\nVAR 209 0\nVAR 210 0\nVAR 211 0\nVAR 212 0\nVAR 213 0\nVAR 214 0\nVAR 215 0\nVAR 216 0\nVAR 217 0\nVAR 218 0\nVAR 219 0\nVAR 220 0\nVAR 221 0\nVAR 222 0\nVAR 223 0\nVAR 224 0\nVAR 225 0\nVAR 226 0\nVAR 227 0\nVAR 228 0\nVAR 229 0\nVAR 230 0\nVAR 231 0\nVAR 232 0\nVAR 233 0\nVAR 234 0\nVAR 235 0\nVAR 236 0\nVAR 237 0\nVAR 238 0\nVAR 239 0\nVAR 240 0\nVAR 241 0\nVAR 242 0\nVAR 243 0\nVAR 244 0\nVAR 245 0\nVAR 246 0\nVAR 247 0\nVAR 248 0\nVAR 249 0\nVAR 250 0\nVAR 251 0\nVAR 252 0\nVAR 253 0\nVAR 254 0\nVAR 255 0\nVAR 256 0\n`\nlet bytecode = bytescript.compileCode({ code: prog2 })\n"]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":3237,"length1":98,"diffs":[[1,"            let parts = (line.split(\" \")) || [\"HALT\"]\n"]]},{"start1":4696,"length1":122,"diffs":[[1,"                default:console.log(\"Build Warning: Command\" + parts[0] + \" Not Supported.\")\n"]]},{"start1":4856,"length1":67,"diffs":[[1,"                return {};\n"]]}]}]},{"timestamp":1756415105073,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":123,"length1":7,"diffs":[[1,"PRINT HEYA the text cannot be multiline , but it can be multi word. ; PRINt text that explains PRINT commands string argmuent.\nVAR A 9 ; set Varible A to 2.\nSUB A 1 ; Subtract 1 from A.\nPRINT A ; Print A's Value to the Console.\nGOTO_IF_NOT_ZERO A 3 ; if A is not zero , subtract one from it again.\nGOTO_IF_ZERO A 7 ; if A is zero go to end of program.\nPRINT PROGRAM COMPLETE! ; print completed program.\n"]]}]}]},{"timestamp":1756415112909,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":123,"length1":67,"diffs":[[1,"PRINT \n"]]},{"start1":132,"length1":155,"diffs":[[1,"let bytecode = bytescript.compileCode({ code: prog })\nconsole.log(bytecode.bytecode)\n//console.log(\"Starting Execute...\")\n//bytescript.runCode({code:prog})"]]}]}]},{"timestamp":1756417007250,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.ts","patch":[{"start1":324,"length1":9,"diffs":[[1,"\n"]]}]}]},{"timestamp":1756417009107,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":123,"length1":91,"diffs":[[1,"VAR A 48\nVAR B 0\nSUB A 2\nADD B 1\nGOTO_IF_ZERO A 7\n; YEE!!!\nPRINT B\n"]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":157,"length1":925,"diffs":[[1,""]]},{"start1":324,"length1":28,"diffs":[[1,"        \n"]]}]}]},{"timestamp":1756417608787,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":123,"length1":36,"diffs":[[1,"main_loop\n  PRINT WELCOME to the main_loop\n  GOTO end_program\nend_program:\n   PRINT ENDED!\n"]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":157,"length1":0,"diffs":[[1,"    function preprocress(lines:string[]) {\n        let labels:{[index:string]:number} = {} // label name -> address\n        let index =0 ;\n        for (let line of lines) {\n            if (line.startsWith(\"lbl \")) {\n                labels[line.replaceAll(\"lbl\",\"\")] = index\n                lines.removeAt(index); // remove it.\n            }\n            index++\n        }\n        index = 0\n        for (let line of lines) {\n            let parts = line.split(\" \")\n            switch (parts[0]) {\n                case \"GOTO\": if (labels[parts[1]]) {lines[index] =  `${parts[0]} ${labels[parts[1]]}`}; break;\n                case \"GOTO_IF_ZERO\": if (labels[parts[2]]) { lines[index] = `${parts[0]} ${parts[1]} ${labels[parts[2]]}` }; break;\n                case \"GOTO_IF_NOT_ZERO\": if (labels[parts[2]]) { lines[index] = `${parts[0]} ${parts[1]} ${labels[parts[2]]}` }; break;\n            }\n            index++;\n        }\n    }\n"]]},{"start1":1249,"length1":0,"diffs":[[1,"        preprocress(lines);\n"]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":1435,"length1":39,"diffs":[[1,"            this._nums.push(v);\n"]]},{"start1":1611,"length1":38,"diffs":[[1,"            this._nums.push(v)\n"]]},{"start1":1769,"length1":38,"diffs":[[1,"            this._nums.push(v)\n"]]},{"start1":1930,"length1":38,"diffs":[[1,"            this._nums.push(v)\n"]]}]}]},{"timestamp":1756418084720,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":159,"length1":1,"diffs":[[1,""]]}]}]},{"timestamp":1756420078168,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":159,"length1":7,"diffs":[[1,"\n"]]}]}]},{"timestamp":1756420133690,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":123,"length1":12,"diffs":[[1,""]]},{"start1":135,"length1":12,"diffs":[[1,"PAUSE 50000\n"]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":436,"length1":0,"diffs":[[1,"\n"]]}]}]},{"timestamp":1756426292262,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":123,"length1":492,"diffs":[[1,"PAUSE 19000\nPRINT HELLO\nPAUSE 10000\nPRINT WORLD\nGOTO 0\n"]]}]}]},{"timestamp":1756426489400,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":108,"length1":15,"diffs":[[1,""]]},{"start1":123,"length1":1265,"diffs":[[1,"; Fibonacci(n) with n = 8\nVAR A 0       ; first term\nVAR B 1       ; second term\nVAR N 8       ; loop counter\nVAR TMP 0     ; temporary for sum\nVAR SCR 0     ; scratch for copies\n\n; LOOP_START at line 6\nVAR TMP 0     ; reset TMP\nADD TMP A     ; TMP = A\nADD TMP B     ; TMP = TMP + B\n\nVAR SCR 0     ; SCR = 0\nADD SCR B     ; SCR = B\nVAR A 0       ; A = 0\nADD A SCR     ; A = SCR (old B)\n\nVAR B 0       ; B = 0\nADD B TMP     ; B = TMP (sum)\n\nSUB N 1       ; N = N - 1\nGOTO_IF_NOT_ZERO N 6\n"]]}]}]},{"timestamp":1756427079614,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":108,"length1":15,"diffs":[[1,"let DIGIT = 32\n"]]},{"start1":1499,"length1":30,"diffs":[[1,""]]},{"start1":1534,"length1":182,"diffs":[[1,"bytescript.runCode({code:prog})"]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":1957,"length1":140,"diffs":[[1,""]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":1998,"length1":314,"diffs":[[1,""]]},{"start1":4646,"length1":192,"diffs":[[1,""]]}]}]},{"timestamp":1756427832555,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":2312,"length1":229,"diffs":[[1,""]]}]}]},{"timestamp":1756427870202,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":138,"length1":38,"diffs":[[1,"  ; Fibonacci(n) with n = 8  => set N to n-1 (here 7) so B = Fib(n) at end\n"]]},{"start1":274,"length1":328,"diffs":[[1,"  VAR N ${DIGIT-1}        ; steps remaining = n - 1\n  VAR T1 0       ; temp sum A+B\n  VAR T2 0       ; temp buffer for copy\n  ; ---- Loop start: build T1 = A + B (preserve A, B) ----\n  GOTO_IF_ZERO A 14\n  SUB A 1\n ADD T1 1\n ADD T2 1\n GOTO 8\n ; done moving from A into T1, T2 holds a copy of A\n GOTO_IF_ZERO T2 19\n SUB T2 1\n ADD A 1\n GOTO 14\n ; A restored, T2 cleared\n ; copy-add B into T1, preserving B via T2\n GOTO_IF_ZERO B 26\n SUB B 1\n ADD T1 1\n ADD T2 1\n GOTO 20\n ; end B loop\n GOTO_IF_ZERO T2 31\n SUB T2 1\n ADD B 1\n GOTO 26\n ; B restored, T2 cleared, now T1 = A + B\n ; ---- Set A = old B (preserve B) ----\n GOTO_IF_ZERO A 36\n SUB A 1\n GOTO 32\n ; A is zero\n GOTO_IF_ZERO B 42\n SUB B 1\n ADD A 1\n ADD T2 1\n GOTO 36\n ; finished copying B to A, T2 holds old B\n GOTO_IF_ZERO T2 47\n SUB T2 1\n ADD B 1\n GOTO 42\n ; B restored, T2 cleared, A = old B\n ; ---- Set B = T1 (destructive move) ----\n GOTO_IF_ZERO B 52\n SUB B 1\n GOTO 48\n ; B is zero\n GOTO_IF_ZERO T1 56\n SUB T1 1\n ADD B 1\n GOTO 52\n ; B now holds A+B, T1 cleared\n ; ---- Decrement N and loop ----\n SUB N 1\n"]]},{"start1":1356,"length1":0,"diffs":[[1," PRINT  the ${DIGIT}th FIB number is:\n"]]},{"start1":1403,"length1":6,"diffs":[[1,"HALT\n"]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":241,"length1":66,"diffs":[[1,"        let vars:{[index:string]:any} = {\"__complied__\":false};\n"]]},{"start1":1957,"length1":204,"diffs":[[1,"                case \"VADD\": vars[parts[1]] += vars[parts[2]]; break;\n                case \"VSUB\": vars[parts[1]] -= vars[parts[2]]; break;\n"]]},{"start1":2292,"length1":160,"diffs":[[1,""]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":2312,"length1":19,"diffs":[[1,"        addNOPwithSig() {\n"]]},{"start1":2369,"length1":170,"diffs":[[1,"            this._nums.push(OPCODES.NOP);\n            this._nums.push(sig & 0xFF);       // low byte\n            this._nums.push((sig >> 8) & 0xFF); // high byte\n"]]},{"start1":6164,"length1":23,"diffs":[[1,""]]}]}]},{"timestamp":1756428459915,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":138,"length1":487,"diffs":[[1,"    ; Fast Fibonacci with VADD / VSUB\n  VAR A 0        ; first term\n  VAR B 1        ; second term\n  VAR N 31       ; loop count = n - 1 (so Fib(32) at end)\n  VAR TMP 0      ; temporary\n \n  ; ---- Loop start ----\n  VAR TMP 0      ; TMP = 0\n  ADD TMP A      ; TMP = A\n VADD TMP B     ; TMP = A + B\n VAR A 0        ; A = 0\n ADD A B        ; A = old B\n VAR B 0        ; B = 0\nVADD B TMP      ; B = sum\n SUB N 1        ; N = N - 1\n GOTO_IF_NOT_ZERO N 8\n PRINT B\n HALT\n"]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":1959,"length1":208,"diffs":[[1,"                case \"VADD\": vars[parts[1]] = intify(vars[parts[1]]) + intify(vars[parts[2]]); break;\n                case \"VSUB\": vars[parts[1]] = intify(vars[parts[1]]) - intify(vars[parts[2]]); break;\n"]]}]}]},{"timestamp":1756428636760,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.ts","patch":[{"start1":157,"length1":1775,"diffs":[[1,""]]}]}]},{"timestamp":1756429446301,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.ts","patch":[{"start1":157,"length1":59,"diffs":[[1,"    function preprocess(lines, buildMode = false) {\n"]]}]}]},{"timestamp":1756429448820,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.ts","patch":[{"start1":157,"length1":116,"diffs":[[1,"    export function preprocess(lines, buildMode = false) {\n        const labelMap = new Map();\n"]]},{"start1":337,"length1":37,"diffs":[[1,"        lines.forEach(lineRaw => {\n"]]},{"start1":1005,"length1":33,"diffs":[[1,"        const out = [];\n"]]},{"start1":1103,"length1":96,"diffs":[[1,"            if (!line) return;                   // skip blanks always\n"]]},{"start1":2023,"length1":41,"diffs":[[1,""]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":3569,"length1":39,"diffs":[[1,""]]}]}]},{"timestamp":1756430121531,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":4503,"length1":90,"diffs":[[1,"                case \"PRINT\": console.log(\"Build Warning:PRINT not supported\");break;\n"]]}]}]},{"timestamp":1756430197970,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":2312,"length1":153,"diffs":[[1,""]]},{"start1":4503,"length1":153,"diffs":[[1,"                case \"PRINT\": partconsole.log(\"Build Warning:PRINT not supported\");break;\n"]]}]}]},{"timestamp":1756430291212,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":138,"length1":46,"diffs":[[1," ; Fast Fibonacci with VADD / VSUB\n"]]},{"start1":337,"length1":12,"diffs":[[1,""]]},{"start1":362,"length1":25,"diffs":[[1,"VADD TMP A      ; TMP = A\n"]]},{"start1":441,"length1":27,"diffs":[[1,"VADD A B        ; A = old B\n"]]},{"start1":493,"length1":25,"diffs":[[1,"VADD B TMP      ; B = sum   (could be VADD B TMP too – both ok here)\n"]]},{"start1":590,"length1":30,"diffs":[[1,"GOTO_IF_NOT_ZERO N 7\n"]]},{"start1":620,"length1":81,"diffs":[[1,"HALT\n"]]}]}]},{"timestamp":1756431024992,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":843,"length1":35,"diffs":[[1,"bytescript.runCode({code:prog})\n"]]}]}]},{"timestamp":1756431028378,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":360,"length1":197,"diffs":[[1,"VAR TMP 0      ; TMP = 0\nVADD TMP A     ; TMP = A\nVADD TMP B     ; TMP = A + B\n"]]},{"start1":440,"length1":145,"diffs":[[1,"VAR A 0        ; A = 0\nVADD A B       ; A = old B\n"]]},{"start1":491,"length1":97,"diffs":[[1,"VAR B 0        ; B = 0\nVADD B TMP     ; B = sum\n\nSUB N 1        ; N = N - 1\nGOTO_IF_NOT_ZERO N LOOP_START\n\nPRINT B\nHALT           ; stop execution early, even though end of code would stop anyway\n"]]}]}]},{"timestamp":1756431784432,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":1179,"length1":12,"diffs":[[1,""]]}]}]},{"timestamp":1756432039628,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"bytescript.ts","patch":[{"start1":2080,"length1":39,"diffs":[[1,""]]},{"start1":4047,"length1":123,"diffs":[[1,""]]},{"start1":4236,"length1":22,"diffs":[[1,""]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":1179,"length1":333,"diffs":[[1,"        add\n"]]},{"start1":2362,"length1":33,"diffs":[[1,"            this._nums.push(10);\n"]]},{"start1":5725,"length1":178,"diffs":[[1,""]]}]}]},{"timestamp":1756432638340,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":803,"length1":76,"diffs":[[1,""]]},{"start1":1053,"length1":82,"diffs":[[1,"console.log(`TIME TAKEN:${time} milliseconds to calcuate the ${DIGIT}th fibanchi number`)"]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":2119,"length1":50,"diffs":[[1,""]]},{"start1":2245,"length1":25,"diffs":[[1,""]]},{"start1":2661,"length1":133,"diffs":[[1,"                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n"]]},{"start1":3227,"length1":888,"diffs":[[1,"                case \"MEM_STORE\": break; /**  emularion not doable in running. , but not compling. reason: this interfaceswith a specficvaribles address which is the low-leve repsnrentaion of a varible name , example:A = 1 , HELLO_WORLD_THIS_IS_A_SUPER_LONG_VAR_NAME = 2 , note: no longer howl ong th var nam is , the var address is always... a single byte , that menas 256 varibles max. */\n"]]},{"start1":4174,"length1":137,"diffs":[[1,"                case \"LWR\": break;\n"]]},{"start1":4799,"length1":367,"diffs":[[1,""]]}]}]},{"timestamp":1756433237075,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":108,"length1":14,"diffs":[[1,"let DIGIT = 19\n"]]},{"start1":241,"length1":62,"diffs":[[1,"VAR N 31       ; loop count = n - 1 (so Fib(32) at end)\n"]]},{"start1":845,"length1":44,"diffs":[[1,"    game.showDialog(\"Debug:\",);\n"]]},{"start1":968,"length1":27,"diffs":[[1,""]]},{"start1":998,"length1":0,"diffs":[[1,"console.log(\"Starting Execute...\")\n"]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":1996,"length1":2495,"diffs":[[1,""]]}]}]},{"timestamp":1756433775868,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1220,"length1":87,"diffs":[[1,""]]}]},{"type":"edited","filename":"bytescript.ts","patch":[{"start1":2413,"length1":71,"diffs":[[1,"    function inlineSingleUseLabels(lines: string[]): string[] {\n"]]},{"start1":3331,"length1":1,"diffs":[[1,""]]},{"start1":3432,"length1":520,"diffs":[[1,"            if (parts[0] === \"GOTO\") {\n                let idx = refLabels.indexOf(parts[1]);\n                if (idx !== -1 && refLabels.lastIndexOf(parts[1]) === idx) {\n"]]},{"start1":3646,"length1":83,"diffs":[[1,"                    let labelIdx = labelNames.indexOf(parts[1]);\n"]]},{"start1":3861,"length1":147,"diffs":[[1,"                        while (end < lines.length && lines[end].trim().charAt(lines[end].trim().length - 1) !== \":\") {\n"]]},{"start1":4041,"length1":65,"diffs":[[1,"                        output.push(\"; Inlined from \" + parts[1]);\n"]]},{"start1":4245,"length1":59,"diffs":[[1,"                        continue; // skip pushing the GOTO itself\n"]]},{"start1":4365,"length1":0,"diffs":[[1,"            // Default: push the original line\n"]]},{"start1":4486,"length1":597,"diffs":[[1,"    \n    export function runCode(c:ByteScript) {\n"]]},{"start1":4664,"length1":102,"diffs":[[1,""]]}]},{"type":"edited","filename":"bytescript.compiler.ts","patch":[{"start1":3916,"length1":618,"diffs":[[1,"    export function compileCode(c: ByteScript): ByteCode {\n"]]},{"start1":4055,"length1":102,"diffs":[[1,""]]}]}]},{"timestamp":1756434314393,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":142,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><comment x=\"0\" y=\"0\" w=\"340\" h=\"120\">\n"]]},{"start1":151,"length1":74,"diffs":[[1,"</comment><comment x=\"0\" y=\"0\" w=\"310\" h=\"120\">\n"]]},{"start1":231,"length1":16,"diffs":[[1,"</comment><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"const prog = `\" line1=\"VAR A 20\" line2=\"SUB A 1\" line3=\"GOTO_IF_NOT_ZERO A 1\" line4=\"PRINT COMPLETED PROGRAM\" line5=\"`\" numlines=\"6\" declaredvars=\"prog\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let bytecode = bytescript.compileCode({ code: prog })\" numlines=\"1\" declaredvars=\"bytecode\"></mutation><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">bytecode.bytecode</field></block></value></block></next></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":342,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1756402185140,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1756404823250,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"bytescript.runCode({code:&quot;PRINT 10 \\n GOTO 0&quot;})\" numlines=\"1\"></mutation></block></statement></block></xml>","main.ts":"//bytescript.runCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })\n","README.md":" ","assets.json":"","bytescript.ts":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n\n        while (i < lines.length) {\n            let line = lines[i].trim() || \"HALT\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a:any,b:any) {\n        if (!!b[a]) {\n            return b[a];\n        } else {\n            return a;\n        }\n    }\n}","bytescript.compiler.ts":"/**\n * interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n\n        while (i < lines.length) {\n            let line = lines[i].trim() || \"HALT\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a:any,b:any) {\n        if (!!b[a]) {\n            return b[a];\n        } else {\n            return a;\n        }\n    }\n}\n */\nnamespace bytescript {\n    export function compileCode(c:ByteScript) {}\n}","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"bytescript.ts\",\n        \"bytescript.compiler.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756406624076,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"bytescript.runCode({code:&quot;PRINT 10 \\n GOTO 0&quot;})\" numlines=\"1\"></mutation></block></statement></block></xml>","main.ts":"//bytescript.runCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })\nlet bytecode = bytescript.compileCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 5920\" })\nconsole.log(bytecode.bytecode)","README.md":" ","assets.json":"","bytescript.ts":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n\n        while (i < lines.length) {\n            let line = lines[i].trim() || \"HALT\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a:any,b:any) {\n        if (!!b[a]) {\n            return b[a];\n        } else {\n            return a;\n        }\n    }\n}","bytescript.compiler.ts":"/**\n * interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n\n        while (i < lines.length) {\n            let line = lines[i].trim() || \"HALT\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a:any,b:any) {\n        if (!!b[a]) {\n            return b[a];\n        } else {\n            return a;\n        }\n    }\n}\n */\nnamespace bytescript {\n    type BYTECODE_TYPE = number;\n    export const BYTESCRIPT_BYTECODE_SIG = 79489365;\n    interface ByteCode {\n        bytecode: number[];\n        type: BYTECODE_TYPE;\n    }\n    class BYTESCRIPT_COMP {\n        private _nums: number[] = [];\n        constructor() {\n\n        }\n        get bytecode() {\n            return this._nums;\n        }\n        addGOTO(address: number) {\n            this._nums.push(1)\n            this._nums.push(address & 0xFF);\n            this._nums.push((address >> 8) & 0xFF); // how to?\n        }\n        addADD(varaddress: number, v: number) {\n            this._nums.push(2)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSUB(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addVAR(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addHALT() {\n            this._nums.push(3)\n            this._nums.push(0);\n            this._nums.push(0)\n        }\n        addGOTO_IF_ZERO(varaddress: number, v: number) { \n            this._nums.push(4);\n            this._nums.push(varaddress);\n            this._nums.push(v);\n        }\n        addGOTO_IF_NOT_ZERO(varaddress: number, v: number) { \n            this._nums.push(5)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n    }\n    export function compileCode(c: ByteScript): ByteCode {\n        console.log(\"Starting Build...\")\n        let lines = c.code.split(\"\\n\")\n        let varmap = new Map<string, number>();\n        const curr = new BYTESCRIPT_COMP();\n        console.log(\"Initalized Build...\")\n        for (let line of lines) {\n            line = line.trim()\n            let parts = (line.split(\" \")) || [\"HALT\"]\n            switch (parts[0]) {\n                case \"GOTO\": let addr = parseInt(parts[1]);if (addr < 0 || addr > lines.length-1) {console.log();break;};curr.addGOTO(addr * 3); break; // GOTO 800\n                case \"ADD\": curr.addADD(map(parts[1], varmap), parseInt(parts[2])); break; // ADD A 4\n                case \"SUB\": curr.addSUB(map(parts[1], varmap), parseInt(parts[2])); break; // SUB A 8\n                case \"VAR\": curr.addVAR(map(parts[1], varmap), parseInt(parts[2])); break; // VAR A 2\n                case \"PRINT\": console.log(\"Build Warning:PRINT not supported\");break;\n                case \"HALT\": curr.addHALT();\n                case \"GOTO_IF_ZERO\": curr.addGOTO_IF_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": curr.addGOTO_IF_NOT_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                default:console.log(\"Build Warning: Command\" + parts[0] + \" Not Supported.\")\n            }\n        }\n        console.log(\"Build Completed.\")\n        return { bytecode: curr.bytecode, type: BYTESCRIPT_BYTECODE_SIG };\n    }\n    function map(varName: string, map: Map<string, number>) {\n        if (!map.has(varName)) {\n            map.set(varName, map.valuesArray().length == 0 ? 1 : map.valuesArray()[map.valuesArray().length - 1]++); // if it does not exist , make it.\n        }\n        return map.get(varName); // in any case get it.\n    }\n}","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"bytescript.ts\",\n        \"bytescript.compiler.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756408426599,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"const prog = `\" line1=\"VAR A 20\" line2=\"SUB A 1\" line3=\"GOTO_IF_NOT_ZERO A 1\" line4=\"PRINT COMPLETED PROGRAM\" line5=\"`\" numlines=\"6\" declaredvars=\"prog\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let bytecode = bytescript.compileCode({ code: prog })\" numlines=\"1\" declaredvars=\"bytecode\"></mutation><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">bytecode.bytecode</field></block></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\">Starting Execute...</field></shadow></value><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"bytescript.runCode({code:prog})\" numlines=\"1\"></mutation></block></next></block></next></block></next></block></next></block></statement></block></xml>","main.ts":"//bytescript.runCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })\nconst prog = `\nVAR A 20\nSUB A 1\nGOTO_IF_NOT_ZERO A 1\nPRINT COMPLETED PROGRAM\n`\nlet bytecode = bytescript.compileCode({ code: prog })\nconsole.log(bytecode.bytecode)\n//console.log(\"Starting Execute...\")\n//bytescript.runCode({code:prog})","README.md":"## BYTESCRIPT\r\n\r\nthe imlamton for a basic language called bytescript \r\nbytescript can be: ran via intrupters\r\nor:\r\ncomplied to bytecode \r\nthe bytecode version does not support PRINT ,  reason:\r\n\r\nPRINT would reqiure complex methods to store the string as NOP's or whatever and address matching, etc.\r\nHow Varibles are handled in bytecode: varibles aer assigned a addres of a single byte , taht address refers to the name (diffrent form PRINT , sinc we dont need to know what hte orignal var name was.)","assets.json":"","bytescript.ts":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n\n        while (i < lines.length) {\n            let line = lines[i].trim() || \"HALT\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": break; /**  emularion not doable in running. , but not compling. reason: this interfaceswith a specficvaribles address which is the low-leve repsnrentaion of a varible name , example:A = 1 , HELLO_WORLD_THIS_IS_A_SUPER_LONG_VAR_NAME = 2 , note: no longer howl ong th var nam is , the var address is always... a single byte , that menas 256 varibles max. */\n                case \"SHR\": vars[parts[1]] >>= parseInt(parts[2]); break;\n                case \"SHL\": vars[parts[1]] <<= parseInt(parts[2]); break;\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a:any,b:any) {\n        if (!!b[a]) {\n            return b[a];\n        } else {\n            return a;\n        }\n    }\n}","bytescript.compiler.ts":"/**\n * interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n\n        while (i < lines.length) {\n            let line = lines[i].trim() || \"HALT\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a:any,b:any) {\n        if (!!b[a]) {\n            return b[a];\n        } else {\n            return a;\n        }\n    }\n}\n */\nnamespace bytescript {\n    const USE_32KB_ROM = false;\n    type BYTECODE_TYPE = number;\n    export const BYTESCRIPT_BYTECODE_SIG = 79489365;\n    interface ByteCode {\n        bytecode: number[];\n        type: BYTECODE_TYPE;\n    }\n    class BYTESCRIPT_COMP {\n        private _nums: number[] = [];\n        constructor() {\n\n        }\n        get bytecode() {\n            return this._nums;\n        }\n        addGOTO(address: number) {\n            this._nums.push(1)\n            this._nums.push(address & 0xFF);\n            this._nums.push((address >> 8) & 0xFF); // how to?\n        }\n        addADD(varaddress: number, v: number) {\n            this._nums.push(2)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSUB(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addVAR(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addHALT() {\n            this._nums.push(3)\n            this._nums.push(0);\n            this._nums.push(0)\n        }\n        addGOTO_IF_ZERO(varaddress: number, v: number) { \n            this._nums.push(4);\n            this._nums.push(varaddress);\n            this._nums.push(v);\n        }\n        addGOTO_IF_NOT_ZERO(varaddress: number, v: number) { \n            this._nums.push(5)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSHR(varaddress:number,v:number) {\n            this._nums.push(6)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSHL(varaddress: number, v: number) {\n            this._nums.push(7)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n    }\n    export function compileCode(c: ByteScript): ByteCode {\n        console.log(\"Starting Build...\")\n        let lines = c.code.split(\"\\n\")\n        let varmap = new Map<string, number>();\n        const curr = new BYTESCRIPT_COMP();\n        console.log(\"Initalized Build...\")\n        for (let line of lines) {\n            line = line.trim()\n            let parts = (line.split(\" \")) || [\"HALT\"]\n            switch (parts[0]) {\n                case \"GOTO\": let addr = parseInt(parts[1]);if (addr < 0 || addr > lines.length-1) {console.log(\"Build Error: Address \" + addr + \" To GO TO is Invalid.\");break;};curr.addGOTO(addr * 3); break; // GOTO 800\n                case \"ADD\": curr.addADD(map(parts[1], varmap), parseInt(parts[2])); break; // ADD A 4\n                case \"SUB\": curr.addSUB(map(parts[1], varmap), parseInt(parts[2])); break; // SUB A 8\n                case \"VAR\": curr.addVAR(map(parts[1], varmap), parseInt(parts[2])); break; // VAR A 2\n                case \"PRINT\": console.log(\"Build Warning:PRINT not supported\");break;\n                case \"HALT\": curr.addHALT();\n                case \"GOTO_IF_ZERO\": curr.addGOTO_IF_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": curr.addGOTO_IF_NOT_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": curr.addVAR(parseInt(parts[1]),parseInt(parts[2])); break; // LOW LEVEL.\n                case \"SHR\": curr.addSHR(map(parts[1],varmap),parseInt(parts[2])); break;\n                case \"SHL\": curr.addSHL(map(parts[1], varmap), parseInt(parts[2])); break;\n                default:console.log(\"Build Warning: Command\" + parts[0] + \" Not Supported.\")\n            }\n        }\n        console.log(`Build Completed, Build Info: Varibles Used ${varmap.valuesArray().length}/256, ROM used:${Math.roundWithPrecision(((curr.bytecode.length / 1024) / USE_32_KB) * 100, 4)}% or in alternate format:${lines.length}/${USE_32KB_ROM ? \"32, 768\"} Lines Used.`)\n        return { bytecode: curr.bytecode, type: BYTESCRIPT_BYTECODE_SIG };\n    }\n    function map(varName: string, map: Map<string, number>) {\n        if (!map.has(varName)) {\n            map.set(varName, map.valuesArray().length == 0 ? 0 : map.valuesArray()[map.valuesArray().length - 1]++); // if it does not exist , make it.\n        }\n        const val = map.get(varName);\n        if (val > 255) {\n            console.log(\"Build Crash:Out of Varibles.\")\n            return null;\n        }\n        return val\n    }\n}","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"bytescript.ts\",\n        \"bytescript.compiler.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756410232516,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"const prog = `\" line1=\"VAR A 20\" line2=\"SUB A 1\" line3=\"GOTO_IF_NOT_ZERO A 1\" line4=\"PRINT COMPLETED PROGRAM\" line5=\"`\" numlines=\"6\" declaredvars=\"prog\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let bytecode = bytescript.compileCode({ code: prog })\" numlines=\"1\" declaredvars=\"bytecode\"></mutation><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">bytecode.bytecode</field></block></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\">Starting Execute...</field></shadow></value><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"bytescript.runCode({code:prog})\" numlines=\"1\"></mutation></block></next></block></next></block></next></block></next></block></statement></block></xml>","main.ts":"//bytescript.runCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })\nconst prog = `\nVAR A 20\nSUB A 1\nGOTO_IF_NOT_ZERO A 1\nPRINT COMPLETED PROGRAM\n`\nlet bytecode = bytescript.compileCode({ code: prog })\nconsole.log(bytecode.bytecode)\n//console.log(\"Starting Execute...\")\n//bytescript.runCode({code:prog})","README.md":"## BYTESCRIPT\r\n\r\nthe imlamton for a basic language called bytescript \r\nbytescript can be: ran via intrupters\r\nor:\r\ncomplied to bytecode \r\nthe bytecode version does not support PRINT ,  reason:\r\n\r\nPRINT would reqiure complex methods to store the string as NOP's or whatever and address matching, etc.\r\nHow Varibles are handled in bytecode: varibles aer assigned a addres of a single byte , taht address refers to the name (diffrent form PRINT , sinc we dont need to know what hte orignal var name was.)","assets.json":"","bytescript.ts":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n\n        while (i < lines.length) {\n            let line = lines[i].trim() || \"HALT\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": break; /**  emularion not doable in running. , but not compling. reason: this interfaceswith a specficvaribles address which is the low-leve repsnrentaion of a varible name , example:A = 1 , HELLO_WORLD_THIS_IS_A_SUPER_LONG_VAR_NAME = 2 , note: no longer howl ong th var nam is , the var address is always... a single byte , that menas 256 varibles max. */\n                case \"SHR\": vars[parts[1]] >>= parseInt(parts[2]); break;\n                case \"SHL\": vars[parts[1]] <<= parseInt(parts[2]); break;\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a:any,b:any) {\n        if (!!b[a]) {\n            return b[a];\n        } else {\n            return a;\n        }\n    }\n}","bytescript.compiler.ts":"/**\n * The ByteScript Language.\n */\nnamespace bytescript {\n    const USE_32KB_ROM = false;\n    type BYTECODE_TYPE = number;\n    export const BYTESCRIPT_BYTECODE_SIG = 79489365;\n    interface ByteCode {\n        bytecode: number[];\n        type: BYTECODE_TYPE;\n    }\n    class BYTESCRIPT_COMP {\n        private _nums: number[] = [];\n        constructor() {\n\n        }\n        get bytecode() {\n            return this._nums;\n        }\n        addGOTO(address: number) {\n            this._nums.push(1)\n            this._nums.push(address & 0xFF);\n            this._nums.push((address >> 8) & 0xFF); // how to?\n        }\n        addADD(varaddress: number, v: number) {\n            this._nums.push(2)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSUB(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addVAR(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addHALT() {\n            this._nums.push(3)\n            this._nums.push(0);\n            this._nums.push(0)\n        }\n        addGOTO_IF_ZERO(varaddress: number, v: number) { \n            this._nums.push(4);\n            this._nums.push(varaddress);\n            this._nums.push(v);\n        }\n        addGOTO_IF_NOT_ZERO(varaddress: number, v: number) { \n            this._nums.push(5)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSHR(varaddress:number,v:number) {\n            this._nums.push(6)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSHL(varaddress: number, v: number) {\n            this._nums.push(7)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n    }\n    export function compileCode(c: ByteScript): ByteCode {\n        console.log(\"Starting Build...\")\n        let lines = c.code.split(\"\\n\")\n        let varmap = new Map<string, number>();\n        const curr = new BYTESCRIPT_COMP();\n        console.log(\"Initalized Build...\")\n        for (let line of lines) {\n            line = line.trim()\n            let parts = (line.split(\" \")) || [\"HALT\"]\n            switch (parts[0]) {\n                case \"GOTO\": let addr = parseInt(parts[1]);if (addr < 0 || addr > lines.length-1) {console.log(\"Build Error: Address \" + addr + \" To GO TO is Invalid.\");break;};curr.addGOTO(addr * 3); break; // GOTO 800\n                case \"ADD\": curr.addADD(map(parts[1], varmap), parseInt(parts[2])); break; // ADD A 4\n                case \"SUB\": curr.addSUB(map(parts[1], varmap), parseInt(parts[2])); break; // SUB A 8\n                case \"VAR\": curr.addVAR(map(parts[1], varmap), parseInt(parts[2])); break; // VAR A 2\n                case \"PRINT\": console.log(\"Build Warning:PRINT not supported\");break;\n                case \"HALT\": curr.addHALT();\n                case \"GOTO_IF_ZERO\": curr.addGOTO_IF_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": curr.addGOTO_IF_NOT_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": curr.addVAR(parseInt(parts[1]),parseInt(parts[2])); break; // LOW LEVEL.\n                case \"SHR\": curr.addSHR(map(parts[1],varmap),parseInt(parts[2])); break;\n                case \"SHL\": curr.addSHL(map(parts[1], varmap), parseInt(parts[2])); break;\n                default:console.log(\"Build Warning: Command\" + parts[0] + \" Not Supported.\")\n            }\n        }\n        console.log(`Build Completed, Build Info: Varibles Used ${varmap.valuesArray().length}/256, ROM used:${Math.roundWithPrecision(((curr.bytecode.length / 1024) / (USE_32KB_ROM ? 32 : 4)) * 100, 4)}% or in alternate format:${lines.length}/${USE_32KB_ROM ? \"10,922\" : \"1,365\"} Lines Used. , Asummptions for Size Caluctions: ROM is ${USE_32KB_ROM ? \"32KB\" : \"4KB\"}`)\n        return { bytecode: curr.bytecode, type: BYTESCRIPT_BYTECODE_SIG };\n    }\n    function map(varName: string, map: Map<string, number>) {\n        if (!map.has(varName)) {\n            map.set(varName, map.valuesArray().length == 0 ? 0 : map.valuesArray()[map.valuesArray().length - 1]++); // if it does not exist , make it.\n        }\n        const val = map.get(varName);\n        if (val > 255) {\n            console.log(\"Build Crash:Out of Varibles.\")\n            return null;\n        }\n        return val\n    }\n}","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"bytescript.ts\",\n        \"bytescript.compiler.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756412037134,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><comment x=\"0\" y=\"0\" w=\"340\" h=\"120\">\nconsole.log(\"Starting Execute...\")\n</comment><comment x=\"0\" y=\"0\" w=\"310\" h=\"120\">\nbytescript.runCode({code:prog})\n</comment><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"const prog = `\" line1=\"VAR A 20\" line2=\"SUB A 1\" line3=\"GOTO_IF_NOT_ZERO A 1\" line4=\"PRINT COMPLETED PROGRAM\" line5=\"`\" numlines=\"6\" declaredvars=\"prog\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let bytecode = bytescript.compileCode({ code: prog })\" numlines=\"1\" declaredvars=\"bytecode\"></mutation><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">bytecode.bytecode</field></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"//bytescript.runCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })\nconst prog = `\nPRINT HEYA the text cannot be multiline , but it can be multi word.\nVAR A 20\nSUB A 1\nPRINT A\nGOTO_IF_NOT_ZERO A 3\nGOTO_IF_ZERO A 7\nPRINT COMPLETE!\n`\n//let bytecode = bytescript.compileCode({ code: prog })\n//console.log(bytecode.bytecode)\nconsole.log(\"Starting Execute...\")\nbytescript.runCode({code:prog})","README.md":"## BYTESCRIPT\r\n\r\nthe imlamton for a basic language called bytescript \r\nbytescript can be: ran via intrupters\r\nor:\r\ncomplied to bytecode \r\nthe bytecode version does not support PRINT ,  reason:\r\n\r\nPRINT would reqiure complex methods to store the string as NOP's or whatever and address matching, etc.\r\nHow Varibles are handled in bytecode: varibles aer assigned a addres of a single byte , taht address refers to the name (diffrent form PRINT , sinc we dont need to know what hte orignal var name was.)","assets.json":"","bytescript.ts":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n\n        while (i < lines.length) {\n            let line = lines[i].trim() || \"NOP\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": break; /**  emularion not doable in running. , but not compling. reason: this interfaceswith a specficvaribles address which is the low-leve repsnrentaion of a varible name , example:A = 1 , HELLO_WORLD_THIS_IS_A_SUPER_LONG_VAR_NAME = 2 , note: no longer howl ong th var nam is , the var address is always... a single byte , that menas 256 varibles max. */\n                case \"SHR\": vars[parts[1]] >>= parseInt(parts[2]); break;\n                case \"SHL\": vars[parts[1]] <<= parseInt(parts[2]); break;\n                case \"PAUSE\": pause(parseInt(parts[1]) / 50);break // assumes 50khz clock rate for emulation.\n                case \"NOP\":break;\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a:any,b:any) {\n        if (!!b[a]) {\n            return b[a];\n        } else {\n            return a;\n        }\n    }\n}","bytescript.compiler.ts":"/**\n * The ByteScript Language.\n */\nnamespace bytescript {\n    const USE_32KB_ROM = false;\n    type BYTECODE_TYPE = number;\n    export let BYTECODE_SUPPORTS_PAUSE = true;\n    export const BYTESCRIPT_BYTECODE_SIG = 79489365;\n    interface ByteCode {\n        bytecode: number[];\n        type: BYTECODE_TYPE;\n    }\n    /** For Internal Use Only. */\n    class BYTESCRIPT_COMP {\n        private _nums: number[] = [];\n        constructor() {\n\n        }\n        get bytecode() {\n            return this._nums;\n        }\n        addGOTO(address: number) {\n            this._nums.push(1)\n            this._nums.push(address & 0xFF);\n            this._nums.push((address >> 8) & 0xFF); // how to?\n        }\n        addADD(varaddress: number, v: number) {\n            this._nums.push(2)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSUB(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addVAR(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addHALT() {\n            this._nums.push(3)\n            this._nums.push(0);\n            this._nums.push(0)\n        }\n        addGOTO_IF_ZERO(varaddress: number, v: number) { \n            this._nums.push(4);\n            this._nums.push(varaddress);\n            this._nums.push(v);\n        }\n        addGOTO_IF_NOT_ZERO(varaddress: number, v: number) { \n            this._nums.push(5)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSHR(varaddress:number,v:number) {\n            this._nums.push(6)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSHL(varaddress: number, v: number) {\n            this._nums.push(7)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addPAUSE(time:number) {\n            // assumption: BYTECODE_SUPPORTS_PAUSE is defined and valid.\n            if (BYTECODE_SUPPORTS_PAUSE) {\n                // supported , allows wait up to 65535 cycles.\n                this._nums.push(8)\n                this._nums.push(time & 0xFF);\n                this._nums.push((time >> 8) & 0xFF);\n            } else {\n                // fallback:NOP train. , only good for few cycle pauses , else... it takes up to much binary size , though this allows any wait time (though it tkaeis up lines of code.)\n                for (let i = 0; i < time; i++) {\n                    this._nums.push(0)\n                    this._nums.push(0)\n                    this._nums.push(0)\n                }\n            }\n        }\n        addNOP() {\n            this._nums.push(0)\n            this._nums.push(0)\n            this._nums.push(0)\n        }\n    }\n    export function compileCode(c: ByteScript): ByteCode {\n        console.log(\"Starting Build...\")\n        let lines = c.code.split(\"\\n\")\n        let varmap = new Map<string, number>();\n        const curr = new BYTESCRIPT_COMP();\n        console.log(\"Initalized Build...\")\n        for (let line of lines) {\n            line = line.trim()\n            let parts = (line.split(\" \")) || [\"HALT\"]\n            switch (parts[0]) {\n                case \"GOTO\": let addr = parseInt(parts[1]);if (addr < 0 || addr > lines.length-1) {console.log(\"Build Error: Address \" + addr + \" To GO TO is Invalid.\");break;};curr.addGOTO(addr * 3); break; // GOTO 800\n                case \"ADD\": curr.addADD(map(parts[1], varmap), parseInt(parts[2])); break; // ADD A 4\n                case \"SUB\": curr.addSUB(map(parts[1], varmap), parseInt(parts[2])); break; // SUB A 8\n                case \"VAR\": curr.addVAR(map(parts[1], varmap), parseInt(parts[2])); break; // VAR A 2\n                case \"PRINT\": console.log(\"Build Warning:PRINT not supported\");break;\n                case \"HALT\": curr.addHALT();\n                case \"GOTO_IF_ZERO\": curr.addGOTO_IF_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": curr.addGOTO_IF_NOT_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": curr.addVAR(parseInt(parts[1]),parseInt(parts[2])); break; // LOW LEVEL.\n                case \"SHR\": curr.addSHR(map(parts[1],varmap),parseInt(parts[2])); break;\n                case \"SHL\": curr.addSHL(map(parts[1], varmap), parseInt(parts[2])); break;\n                case \"PAUSE\": curr.addPAUSE(parseInt(parts[1])); break;\n                case \"NOP\":curr.addNOP(); break;\n                default:console.log(\"Build Warning: Command\" + parts[0] + \" Not Supported.\")\n            }\n        }\n        console.log(`Build Completed, Build Info: Varibles Used ${varmap.valuesArray().length}/256, ROM used:${Math.roundWithPrecision(((curr.bytecode.length / 1024) / (USE_32KB_ROM ? 32 : 4)) * 100, 4)}% or in alternate format:${curr.bytecode.length / 3}/${USE_32KB_ROM ? \"10,922\" : \"1,365\"} Lines Used. , Asummptions for Size Caluctions: ROM is ${USE_32KB_ROM ? \"32KB\" : \"4KB\"}`)\n        return { bytecode: curr.bytecode, type: BYTESCRIPT_BYTECODE_SIG };\n    }\n    function map(varName: string, map: Map<string, number>) {\n        if (!map.has(varName)) {\n            map.set(varName, map.valuesArray().length == 0 ? 0 : map.valuesArray()[map.valuesArray().length - 1]++); // if it does not exist , make it.\n        }\n        const val = map.get(varName);\n        if (val > 255) {\n            console.log(\"Build Crash:Out of Varibles.\")\n            return null;\n        }\n        return val\n    }\n}","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"bytescript.ts\",\n        \"bytescript.compiler.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756414934577,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><comment x=\"0\" y=\"0\" w=\"340\" h=\"120\">\nconsole.log(\"Starting Execute...\")\n</comment><comment x=\"0\" y=\"0\" w=\"310\" h=\"120\">\nbytescript.runCode({code:prog})\n</comment><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"const prog = `\" line1=\"VAR A 20\" line2=\"SUB A 1\" line3=\"GOTO_IF_NOT_ZERO A 1\" line4=\"PRINT COMPLETED PROGRAM\" line5=\"`\" numlines=\"6\" declaredvars=\"prog\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let bytecode = bytescript.compileCode({ code: prog })\" numlines=\"1\" declaredvars=\"bytecode\"></mutation><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">bytecode.bytecode</field></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"//bytescript.runCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })\nconst prog = `\nPRINT HEYA the text cannot be multiline , but it can be multi word. ; PRINt text that explains PRINT commands string argmuent.\nVAR A 9 ; set Varible A to 2.\nSUB A 1 ; Subtract 1 from A.\nPRINT A ; Print A's Value to the Console.\nGOTO_IF_NOT_ZERO A 3 ; if A is not zero , subtract one from it again.\nGOTO_IF_ZERO A 7 ; if A is zero go to end of program.\nPRINT PROGRAM COMPLETE! ; print completed program.\n`\nlet bytecode = bytescript.compileCode({ code: prog })\nconsole.log(bytecode.bytecode)\n//console.log(\"Starting Execute...\")\n//bytescript.runCode({code:prog})","README.md":"## BYTESCRIPT\r\n\r\nthe imlamton for a basic language called bytescript \r\nbytescript can be: ran via intrupters\r\nor:\r\ncomplied to bytecode \r\nthe bytecode version does not support PRINT ,  reason:\r\n\r\nPRINT would reqiure complex methods to store the string as NOP's or whatever and address matching, etc.\r\nHow Varibles are handled in bytecode: varibles aer assigned a addres of a single byte , taht address refers to the name (diffrent form PRINT , sinc we dont need to know what hte orignal var name was.)","assets.json":"","bytescript.ts":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    function _parseInt(a:string):any {\n        return parseInt(a);\n    }\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n\n        while (i < lines.length) {\n            let line = lines[i].trim().split(\";\")[0] || \"NOP\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = _parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": break; /**  emularion not doable in running. , but not compling. reason: this interfaceswith a specficvaribles address which is the low-leve repsnrentaion of a varible name , example:A = 1 , HELLO_WORLD_THIS_IS_A_SUPER_LONG_VAR_NAME = 2 , note: no longer howl ong th var nam is , the var address is always... a single byte , that menas 256 varibles max. */\n                case \"SHR\": vars[parts[1]] >>= _parseInt(parts[2]); break;\n                case \"SHL\": vars[parts[1]] <<= _parseInt(parts[2]); break;\n                case \"PAUSE\": pause(parseInt(parts[1]) / 50);break // assumes 50khz clock rate for emulation.\n                case \"NOP\":break;\n                default: console.log(\"Intrepter Crash: Invalid Command\");return;\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a: string, b: { [index: string]: any }) {\n        const A_WORD = a.split(\" \")[0]\n        if (!!b[A_WORD]) {\n            return b[A_WORD];\n        } else {\n            return a;\n        }\n    }\n}","bytescript.compiler.ts":"/**\n * The ByteScript Language.\n */\nnamespace bytescript {\n    const USE_32KB_ROM = false;\n    type BYTECODE_TYPE = number;\n    export let BYTECODE_SUPPORTS_PAUSE = true;\n    export const BYTESCRIPT_BYTECODE_SIG = 79489365;\n    interface ByteCode {\n        bytecode: number[];\n        type: BYTECODE_TYPE;\n    }\n    /** For Internal Use Only. */\n    class BYTESCRIPT_COMP {\n        private _nums: number[] = [];\n        constructor() {\n\n        }\n        get bytecode() {\n            return this._nums;\n        }\n        addGOTO(address: number) {\n            this._nums.push(1)\n            this._nums.push(address & 0xFF);\n            this._nums.push((address >> 8) & 0xFF); // how to?\n        }\n        addADD(varaddress: number, v: number) {\n            this._nums.push(2)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSUB(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addVAR(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addHALT() {\n            this._nums.push(3)\n            this._nums.push(0);\n            this._nums.push(0)\n        }\n        addGOTO_IF_ZERO(varaddress: number, v: number) { \n            this._nums.push(4);\n            this._nums.push(varaddress);\n            this._nums.push(v);\n        }\n        addGOTO_IF_NOT_ZERO(varaddress: number, v: number) { \n            this._nums.push(5)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSHR(varaddress:number,v:number) {\n            this._nums.push(6)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSHL(varaddress: number, v: number) {\n            this._nums.push(7)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addPAUSE(time:number) {\n            // assumption: BYTECODE_SUPPORTS_PAUSE is defined and valid.\n            if (BYTECODE_SUPPORTS_PAUSE) {\n                // supported , allows wait up to 65535 cycles.\n                this._nums.push(8)\n                this._nums.push(time & 0xFF);\n                this._nums.push((time >> 8) & 0xFF);\n            } else {\n                // fallback:NOP train. , only good for few cycle pauses , else... it takes up to much binary size , though this allows any wait time (though it tkaeis up lines of code.)\n                for (let i = 0; i < time; i++) {\n                    this._nums.push(0)\n                    this._nums.push(0)\n                    this._nums.push(0)\n                }\n            }\n        }\n        addNOP() {\n            this._nums.push(0)\n            this._nums.push(0)\n            this._nums.push(0)\n        }\n    }\n    export function compileCode(c: ByteScript): ByteCode {\n        console.log(\"Starting Build...\")\n        let lines = c.code.split(\"\\n\")\n        let varmap = new Map<string, number>();\n        const curr = new BYTESCRIPT_COMP();\n        console.log(\"Initalized Build...\")\n        for (let line of lines) {\n            line = line.trim()\n            line = line.split(\";\")[0];\n            let parts = (line.split(\" \")) || [\"NOP\",\"0\"]\n            if (parts[0] == \"\") continue\n            switch (parts[0]) {\n                case \"GOTO\": let addr = parseInt(parts[1]);if (addr < 0 || addr > lines.length-1) {console.log(\"Build Error: Address \" + addr + \" To GO TO is Invalid.\");break;};curr.addGOTO(addr * 3); break; // GOTO 800\n                case \"ADD\": curr.addADD(map(parts[1], varmap), parseInt(parts[2])); break; // ADD A 4\n                case \"SUB\": curr.addSUB(map(parts[1], varmap), parseInt(parts[2])); break; // SUB A 8\n                case \"VAR\": curr.addVAR(map(parts[1], varmap), parseInt(parts[2])); break; // VAR A 2\n                case \"PRINT\": console.log(\"Build Warning:PRINT not supported\");break;\n                case \"HALT\": curr.addHALT();\n                case \"GOTO_IF_ZERO\": curr.addGOTO_IF_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": curr.addGOTO_IF_NOT_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": curr.addVAR(parseInt(parts[1]),parseInt(parts[2])); break; // LOW LEVEL.\n                case \"SHR\": curr.addSHR(map(parts[1],varmap),parseInt(parts[2])); break;\n                case \"SHL\": curr.addSHL(map(parts[1], varmap), parseInt(parts[2])); break;\n                case \"PAUSE\": curr.addPAUSE(parseInt(parts[1])); break;\n                case \"NOP\":curr.addNOP(); break;\n                default:console.log(\"Build Warning: Command \" + (parts[0] || \"EMPTY_STRING\") + \" Not Supported.\"); break;\n            }\n            if (varmap.valuesArray().length > 255) {\n                return {bytecode:[],type:BYTESCRIPT_BYTECODE_SIG};\n            }\n        }\n        console.log(`Build Completed, Build Info: Varibles Used ${varmap.valuesArray().length}/256, ROM used:${Math.roundWithPrecision(((curr.bytecode.length / 1024) / (USE_32KB_ROM ? 32 : 4)) * 100, 4)}% or in alternate format:${curr.bytecode.length / 3}/${USE_32KB_ROM ? \"10,922\" : \"1,365\"} Lines Used. , Asummptions for Size Caluctions: ROM is ${USE_32KB_ROM ? \"32KB\" : \"4KB\"}`)\n        return { bytecode: curr.bytecode, type: BYTESCRIPT_BYTECODE_SIG };\n    }\n    function map(varName: string, map: Map<string, number>) {\n        if (!map.has(varName)) {\n            map.set(varName, map.valuesArray().length == 0 ? 0 : map.valuesArray()[map.valuesArray().length - 1]++); // if it does not exist , make it.\n        }\n        const val = map.get(varName);\n        if (val > 255) {\n            console.log(\"Build Crash:Out of Varibles.\")\n            return null;\n        }\n        return val\n    }\n}","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"bytescript.ts\",\n        \"bytescript.compiler.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756417007250,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><comment x=\"0\" y=\"0\" w=\"340\" h=\"120\">\nconsole.log(\"Starting Execute...\")\n</comment><comment x=\"0\" y=\"0\" w=\"310\" h=\"120\">\nbytescript.runCode({code:prog})\n</comment><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"const prog = `\" line1=\"VAR A 20\" line2=\"SUB A 1\" line3=\"GOTO_IF_NOT_ZERO A 1\" line4=\"PRINT COMPLETED PROGRAM\" line5=\"`\" numlines=\"6\" declaredvars=\"prog\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let bytecode = bytescript.compileCode({ code: prog })\" numlines=\"1\" declaredvars=\"bytecode\"></mutation><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">bytecode.bytecode</field></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"//bytescript.runCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })\nconst prog = `\nVAR A 48\nVAR B 0\nSUB A 2\nADD B 1\nGOTO_IF_ZERO A 7\n; YEE!!!\nPRINT B\n`\n//let bytecode = bytescript.compileCode({ code: prog })\n//console.log(bytecode.bytecode)\nconsole.log(\"Starting Execute...\")\nbytescript.runCode({code:prog})","README.md":"## BYTESCRIPT\r\n\r\nthe imlamton for a basic language called bytescript \r\nbytescript can be: ran via intrupters\r\nor:\r\ncomplied to bytecode \r\nthe bytecode version does not support PRINT ,  reason:\r\n\r\nPRINT would reqiure complex methods to store the string as NOP's or whatever and address matching, etc.\r\nHow Varibles are handled in bytecode: varibles aer assigned a addres of a single byte , taht address refers to the name (diffrent form PRINT , sinc we dont need to know what hte orignal var name was.)","assets.json":"","bytescript.ts":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    function _parseInt(a:string):any {\n        return parseInt(a);\n    }\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n\n        while (i < lines.length) {\n            let line = lines[i].trim().split(\";\")[0] || \"NOP\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = _parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": break; /**  emularion not doable in running. , but not compling. reason: this interfaceswith a specficvaribles address which is the low-leve repsnrentaion of a varible name , example:A = 1 , HELLO_WORLD_THIS_IS_A_SUPER_LONG_VAR_NAME = 2 , note: no longer howl ong th var nam is , the var address is always... a single byte , that menas 256 varibles max. */\n                case \"SHR\": vars[parts[1]] >>= _parseInt(parts[2]); break;\n                case \"SHL\": vars[parts[1]] <<= _parseInt(parts[2]); break;\n                case \"PAUSE\": pause(parseInt(parts[1]) / 50);break // assumes 50khz clock rate for emulation.\n                case \"NOP\":break;\n                default: console.log(\"Intrepter Crash: Invalid Command\");return;\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a: string, b: { [index: string]: any }) {\n        const A_WORD = a.split(\" \")[0]\n        if (!!b[A_WORD]) {\n            return b[A_WORD];\n        } else {\n            return a;\n        }\n    }\n}","bytescript.compiler.ts":"/**\n * The ByteScript Language.\n */\nnamespace bytescript {\n    const USE_32KB_ROM = false;\n    type BYTECODE_TYPE = number;\n    export let BYTECODE_SUPPORTS_PAUSE = true;\n    export const BYTESCRIPT_BYTECODE_SIG = 79489365;\n    interface ByteCode {\n        bytecode: number[];\n        type: BYTECODE_TYPE;\n    }\n    /** For Internal Use Only. */\n    class BYTESCRIPT_COMP {\n        private _nums: number[] = [];\n        constructor() {\n\n        }\n        get bytecode() {\n            return this._nums;\n        }\n        addGOTO(address: number) {\n            this._nums.push(1)\n            this._nums.push(address & 0xFF);\n            this._nums.push((address >> 8) & 0xFF); // how to?\n        }\n        addADD(varaddress: number, v: number) {\n            this._nums.push(2)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSUB(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addVAR(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addHALT() {\n            this._nums.push(3)\n            this._nums.push(0);\n            this._nums.push(0)\n        }\n        addGOTO_IF_ZERO(varaddress: number, v: number) { \n            this._nums.push(4);\n            this._nums.push(varaddress);\n            this._nums.push(v);\n        }\n        addGOTO_IF_NOT_ZERO(varaddress: number, v: number) { \n            this._nums.push(5)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSHR(varaddress:number,v:number) {\n            this._nums.push(6)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSHL(varaddress: number, v: number) {\n            this._nums.push(7)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addPAUSE(time:number) {\n            // assumption: BYTECODE_SUPPORTS_PAUSE is defined and valid.\n            if (BYTECODE_SUPPORTS_PAUSE) {\n                // supported , allows wait up to 65535 cycles.\n                this._nums.push(8)\n                this._nums.push(time & 0xFF);\n                this._nums.push((time >> 8) & 0xFF);\n            } else {\n                // fallback:NOP train. , only good for few cycle pauses , else... it takes up to much binary size , though this allows any wait time (though it tkaeis up lines of code.)\n                for (let i = 0; i < time; i++) {\n                    this._nums.push(0)\n                    this._nums.push(0)\n                    this._nums.push(0)\n                }\n            }\n        }\n        addNOP() {\n            this._nums.push(0)\n            this._nums.push(0)\n            this._nums.push(0)\n        }\n    }\n    export function compileCode(c: ByteScript): ByteCode {\n        console.log(\"Starting Build...\")\n        let lines = c.code.split(\"\\n\")\n        let varmap = new Map<string, number>();\n        const curr = new BYTESCRIPT_COMP();\n        console.log(\"Initalized Build...\")\n        for (let line of lines) {\n            line = line.trim()\n            line = line.split(\";\")[0];\n            let parts = (line.split(\" \")) || [\"NOP\",\"0\"]\n            if (parts[0] == \"\") continue\n            switch (parts[0]) {\n                case \"GOTO\": let addr = parseInt(parts[1]);if (addr < 0 || addr > lines.length-1) {console.log(\"Build Error: Address \" + addr + \" To GO TO is Invalid.\");break;};curr.addGOTO(addr * 3); break; // GOTO 800\n                case \"ADD\": curr.addADD(map(parts[1], varmap), parseInt(parts[2])); break; // ADD A 4\n                case \"SUB\": curr.addSUB(map(parts[1], varmap), parseInt(parts[2])); break; // SUB A 8\n                case \"VAR\": curr.addVAR(map(parts[1], varmap), parseInt(parts[2])); break; // VAR A 2\n                case \"PRINT\": console.log(\"Build Warning:PRINT not supported\");break;\n                case \"HALT\": curr.addHALT();\n                case \"GOTO_IF_ZERO\": curr.addGOTO_IF_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": curr.addGOTO_IF_NOT_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": curr.addVAR(parseInt(parts[1]),parseInt(parts[2])); break; // LOW LEVEL.\n                case \"SHR\": curr.addSHR(map(parts[1],varmap),parseInt(parts[2])); break;\n                case \"SHL\": curr.addSHL(map(parts[1], varmap), parseInt(parts[2])); break;\n                case \"PAUSE\": curr.addPAUSE(parseInt(parts[1])); break;\n                case \"NOP\":curr.addNOP(); break;\n                default:console.log(\"Build Warning: Command \" + (parts[0] || \"EMPTY_STRING\") + \" Not Supported.\"); break;\n            }\n            if (varmap.valuesArray().length > 255) {\n                return {bytecode:[],type:BYTESCRIPT_BYTECODE_SIG};\n            }\n        }\n        console.log(`Build Completed, Build Info: Varibles Used ${varmap.valuesArray().length}/256, ROM used:${Math.roundWithPrecision(((curr.bytecode.length / 1024) / (USE_32KB_ROM ? 32 : 4)) * 100, 4)}% or in alternate format:${curr.bytecode.length / 3}/${USE_32KB_ROM ? \"10,922\" : \"1,365\"} Lines Used. , Asummptions for Size Caluctions: ROM is ${USE_32KB_ROM ? \"32KB\" : \"4KB\"}`)\n        return { bytecode: curr.bytecode, type: BYTESCRIPT_BYTECODE_SIG };\n    }\n    function map(varName: string, map: Map<string, number>) {\n        if (!map.has(varName)) {\n            map.set(varName, map.valuesArray().length == 0 ? 0 : map.valuesArray()[map.valuesArray().length - 1]++); // if it does not exist , make it.\n        }\n        const val = map.get(varName);\n        if (val > 255) {\n            console.log(\"Build Crash:Out of Varibles.\")\n            return null;\n        }\n        return val\n    }\n}","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"bytescript.ts\",\n        \"bytescript.compiler.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756420078168,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><comment x=\"0\" y=\"0\" w=\"340\" h=\"120\">\nconsole.log(\"Starting Execute...\")\n</comment><comment x=\"0\" y=\"0\" w=\"310\" h=\"120\">\nbytescript.runCode({code:prog})\n</comment><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"const prog = `\" line1=\"VAR A 20\" line2=\"SUB A 1\" line3=\"GOTO_IF_NOT_ZERO A 1\" line4=\"PRINT COMPLETED PROGRAM\" line5=\"`\" numlines=\"6\" declaredvars=\"prog\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let bytecode = bytescript.compileCode({ code: prog })\" numlines=\"1\" declaredvars=\"bytecode\"></mutation><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">bytecode.bytecode</field></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"//bytescript.runCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })\nconst prog = `\nPRINT HELLO\nPAUSE 50000\nPRINT WORLD\n`\n//let bytecode = bytescript.compileCode({ code: prog })\n//console.log(bytecode.bytecode)\nconsole.log(\"Starting Execute...\")\nbytescript.runCode({code:prog})","README.md":"## BYTESCRIPT\r\n\r\nthe imlamton for a basic language called bytescript \r\nbytescript can be: ran via intrupters\r\nor:\r\ncomplied to bytecode \r\nthe bytecode version does not support PRINT ,  reason:\r\n\r\nPRINT would reqiure complex methods to store the string as NOP's or whatever and address matching, etc.\r\nHow Varibles are handled in bytecode: varibles aer assigned a addres of a single byte , taht address refers to the name (diffrent form PRINT , sinc we dont need to know what hte orignal var name was.)","assets.json":"","bytescript.ts":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    function _parseInt(a:string):any {\n        return parseInt(a);\n    }\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n        while (i < lines.length) {\n            let line = lines[i].trim().split(\";\")[0] || \"NOP\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = _parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": break; /**  emularion not doable in running. , but not compling. reason: this interfaceswith a specficvaribles address which is the low-leve repsnrentaion of a varible name , example:A = 1 , HELLO_WORLD_THIS_IS_A_SUPER_LONG_VAR_NAME = 2 , note: no longer howl ong th var nam is , the var address is always... a single byte , that menas 256 varibles max. */\n                case \"SHR\": vars[parts[1]] >>= _parseInt(parts[2]); break;\n                case \"SHL\": vars[parts[1]] <<= _parseInt(parts[2]); break;\n                case \"PAUSE\": pause(parseInt(parts[1]) / 50);break // assumes 50khz clock rate for emulation.\n                case \"NOP\":break;\n                default: console.log(\"Intrepter Crash: Invalid Command\");return;\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a: string, b: { [index: string]: any }) {\n        const A_WORD = a.split(\" \")[0]\n        if (!!b[A_WORD]) {\n            return b[A_WORD];\n        } else {\n            return a;\n        }\n    }\n}","bytescript.compiler.ts":"/**\n * The ByteScript Language.\n */\nnamespace bytescript {\n    const USE_32KB_ROM = false;\n    type BYTECODE_TYPE = number;\n    export let BYTECODE_SUPPORTS_PAUSE = true;\n    export const BYTESCRIPT_BYTECODE_SIG = 79489365;\n    interface ByteCode {\n        bytecode: number[];\n        type: BYTECODE_TYPE;\n    }\n    /** For Internal Use Only. */\n    class BYTESCRIPT_COMP {\n        private _nums: number[] = [];\n        constructor() {\n\n        }\n        get bytecode() {\n            return this._nums;\n        }\n        addGOTO(address: number) {\n            this._nums.push(1)\n            this._nums.push(address & 0xFF);\n            this._nums.push((address >> 8) & 0xFF); // how to?\n        }\n        addADD(varaddress: number, v: number) {\n            this._nums.push(2)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSUB(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addVAR(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addHALT() {\n            this._nums.push(3)\n            this._nums.push(0);\n            this._nums.push(0)\n        }\n        addGOTO_IF_ZERO(varaddress: number, v: number) { \n            this._nums.push(4);\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF);\n        }\n        addGOTO_IF_NOT_ZERO(varaddress: number, v: number) { \n            this._nums.push(5)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addSHR(varaddress:number,v:number) {\n            this._nums.push(6)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addSHL(varaddress: number, v: number) {\n            this._nums.push(7)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addPAUSE(time:number) {\n            // assumption: BYTECODE_SUPPORTS_PAUSE is defined and valid.\n            if (BYTECODE_SUPPORTS_PAUSE) {\n                // supported , allows wait up to 65535 cycles.\n                this._nums.push(8)\n                this._nums.push(time & 0xFF);\n                this._nums.push((time >> 8) & 0xFF);\n            } else {\n                // fallback:NOP train. , only good for few cycle pauses , else... it takes up to much binary size , though this allows any wait time (though it tkaeis up lines of code.)\n                for (let i = 0; i < time; i++) {\n                    this._nums.push(0)\n                    this._nums.push(0)\n                    this._nums.push(0)\n                }\n            }\n        }\n        addNOP() {\n            this._nums.push(0)\n            this._nums.push(0)\n            this._nums.push(0)\n        }\n    }\n    export function compileCode(c: ByteScript): ByteCode {\n        console.log(\"Starting Build...\")\n        let lines = c.code.split(\"\\n\")\n        let varmap = new Map<string, number>();\n        const curr = new BYTESCRIPT_COMP();\n        console.log(\"Initalized Build...\")\n        for (let line of lines) {\n            line = line.trim()\n            line = line.split(\";\")[0];\n            let parts = (line.split(\" \")) || [\"NOP\",\"0\"]\n            if (parts[0] == \"\") continue\n            switch (parts[0]) {\n                case \"GOTO\": let addr = parseInt(parts[1]);if (addr < 0 || addr > lines.length-1) {console.log(\"Build Error: Address \" + addr + \" To GO TO is Invalid.\");break;};curr.addGOTO(addr * 3); break; // GOTO 800\n                case \"ADD\": curr.addADD(map(parts[1], varmap), parseInt(parts[2])); break; // ADD A 4\n                case \"SUB\": curr.addSUB(map(parts[1], varmap), parseInt(parts[2])); break; // SUB A 8\n                case \"VAR\": curr.addVAR(map(parts[1], varmap), parseInt(parts[2])); break; // VAR A 2\n                case \"PRINT\": console.log(\"Build Warning:PRINT not supported\");break;\n                case \"HALT\": curr.addHALT();\n                case \"GOTO_IF_ZERO\": curr.addGOTO_IF_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": curr.addGOTO_IF_NOT_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": curr.addVAR(parseInt(parts[1]),parseInt(parts[2])); break; // LOW LEVEL.\n                case \"SHR\": curr.addSHR(map(parts[1],varmap),parseInt(parts[2])); break;\n                case \"SHL\": curr.addSHL(map(parts[1], varmap), parseInt(parts[2])); break;\n                case \"PAUSE\": curr.addPAUSE(parseInt(parts[1])); break;\n                case \"NOP\":curr.addNOP(); break;\n                default:console.log(\"Build Warning: Command \" + (parts[0] || \"EMPTY_STRING\") + \" Not Supported.\"); break;\n            }\n            if (varmap.valuesArray().length > 255) {\n                return {bytecode:[],type:BYTESCRIPT_BYTECODE_SIG};\n            }\n        }\n        console.log(`Build Completed, Build Info: Varibles Used ${varmap.valuesArray().length}/256, ROM used:${Math.roundWithPrecision(((curr.bytecode.length / 1024) / (USE_32KB_ROM ? 32 : 4)) * 100, 4)}% or in alternate format:${curr.bytecode.length / 3}/${USE_32KB_ROM ? \"10,922\" : \"1,365\"} Lines Used. , Asummptions for Size Caluctions: ROM is ${USE_32KB_ROM ? \"32KB\" : \"4KB\"}`)\n        return { bytecode: curr.bytecode, type: BYTESCRIPT_BYTECODE_SIG };\n    }\n    function map(varName: string, map: Map<string, number>) {\n        if (!map.has(varName)) {\n            map.set(varName, map.valuesArray().length == 0 ? 0 : map.valuesArray()[map.valuesArray().length - 1]++); // if it does not exist , make it.\n        }\n        const val = map.get(varName);\n        if (val > 255) {\n            console.log(\"Build Crash:Out of Varibles.\")\n            return null;\n        }\n        return val\n    }\n}","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"bytescript.ts\",\n        \"bytescript.compiler.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756425850599,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><comment x=\"0\" y=\"0\" w=\"340\" h=\"120\">\nconsole.log(\"Starting Execute...\")\n</comment><comment x=\"0\" y=\"0\" w=\"310\" h=\"120\">\nbytescript.runCode({code:prog})\n</comment><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"const prog = `\" line1=\"VAR A 20\" line2=\"SUB A 1\" line3=\"GOTO_IF_NOT_ZERO A 1\" line4=\"PRINT COMPLETED PROGRAM\" line5=\"`\" numlines=\"6\" declaredvars=\"prog\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let bytecode = bytescript.compileCode({ code: prog })\" numlines=\"1\" declaredvars=\"bytecode\"></mutation><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">bytecode.bytecode</field></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"//bytescript.runCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })\nconst prog = `\nPAUSE 19000\nPRINT HELLO\nPAUSE 10000\nPRINT WORLD\nGOTO 0\n`\n//let bytecode = bytescript.compileCode({ code: prog })\n//console.log(bytecode.bytecode)\nconsole.log(\"Starting Execute...\")\nbytescript.runCode({code:prog})","README.md":"## BYTESCRIPT\r\n\r\nthe imlamton for a basic language called bytescript \r\nbytescript can be: ran via intrupters\r\nor:\r\ncomplied to bytecode \r\nthe bytecode version does not support PRINT ,  reason:\r\n\r\nPRINT would reqiure complex methods to store the string as NOP's or whatever and address matching, etc.\r\nHow Varibles are handled in bytecode: varibles aer assigned a addres of a single byte , taht address refers to the name (diffrent form PRINT , sinc we dont need to know what hte orignal var name was.)","assets.json":"","bytescript.ts":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    function _parseInt(a:string):any {\n        return parseInt(a);\n    }\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n        while (i < lines.length) {\n            let line = lines[i].trim().split(\";\")[0] || \"NOP\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = _parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": break; /**  emularion not doable in running. , but not compling. reason: this interfaceswith a specficvaribles address which is the low-leve repsnrentaion of a varible name , example:A = 1 , HELLO_WORLD_THIS_IS_A_SUPER_LONG_VAR_NAME = 2 , note: no longer howl ong th var nam is , the var address is always... a single byte , that menas 256 varibles max. */\n                case \"SHR\": vars[parts[1]] >>= _parseInt(parts[2]); break;\n                case \"SHL\": vars[parts[1]] <<= _parseInt(parts[2]); break;\n                case \"PAUSE\": pause(parseInt(parts[1]) / 50);break // assumes 50khz clock rate for emulation.\n                case \"NOP\":break;\n                default: console.log(\"Intrepter Crash: Invalid Command\");return;\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a: string, b: { [index: string]: any }) {\n        const A_WORD = a.split(\" \")[0]\n        if (!!b[A_WORD]) {\n            return b[A_WORD];\n        } else {\n            return a;\n        }\n    }\n}","bytescript.compiler.ts":"/**\n * The ByteScript Language.\n */\nnamespace bytescript {\n    const USE_32KB_ROM = false;\n    type BYTECODE_TYPE = number;\n    export let BYTECODE_SUPPORTS_PAUSE = true;\n    export const BYTESCRIPT_BYTECODE_SIG = 79489365;\n    interface ByteCode {\n        bytecode: number[];\n        type: BYTECODE_TYPE;\n    }\n    /** For Internal Use Only. */\n    class BYTESCRIPT_COMP {\n        private _nums: number[] = [];\n        constructor() {\n        }\n        get bytecode() {\n            return this._nums;\n        }\n        addGOTO(address: number) {\n            this._nums.push(1)\n            this._nums.push(address & 0xFF);\n            this._nums.push((address >> 8) & 0xFF); // how to?\n        }\n        addADD(varaddress: number, v: number) {\n            this._nums.push(2)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSUB(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addVAR(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addHALT() {\n            this._nums.push(3)\n            this._nums.push(0);\n            this._nums.push(0)\n        }\n        addGOTO_IF_ZERO(varaddress: number, v: number) { \n            this._nums.push(4);\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF);\n        }\n        addGOTO_IF_NOT_ZERO(varaddress: number, v: number) { \n            this._nums.push(5)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addSHR(varaddress:number,v:number) {\n            this._nums.push(6)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addSHL(varaddress: number, v: number) {\n            this._nums.push(7)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addPAUSE(time:number) {\n            // assumption: BYTECODE_SUPPORTS_PAUSE is defined and valid.\n            if (BYTECODE_SUPPORTS_PAUSE) {\n                // supported , allows wait up to 65535 cycles.\n                this._nums.push(8)\n                this._nums.push(time & 0xFF);\n                this._nums.push((time >> 8) & 0xFF);\n            } else {\n                // fallback:NOP train. , only good for few cycle pauses , else... it takes up to much binary size , though this allows any wait time (though it tkaeis up lines of code.)\n                for (let i = 0; i < time; i++) {\n                    this._nums.push(0)\n                    this._nums.push(0)\n                    this._nums.push(0)\n                }\n            }\n        }\n        addNOP() {\n            this._nums.push(0)\n            this._nums.push(0)\n            this._nums.push(0)\n        }\n    }\n    export function compileCode(c: ByteScript): ByteCode {\n        console.log(\"Starting Build...\")\n        let lines = c.code.split(\"\\n\")\n        let varmap = new Map<string, number>();\n        const curr = new BYTESCRIPT_COMP();\n        console.log(\"Initalized Build...\")\n        for (let line of lines) {\n            line = line.trim()\n            line = line.split(\";\")[0];\n            let parts = (line.split(\" \")) || [\"NOP\",\"0\"]\n            if (parts[0] == \"\") continue\n            switch (parts[0]) {\n                case \"GOTO\": let addr = parseInt(parts[1]);if (addr < 0 || addr > lines.length-1) {console.log(\"Build Error: Address \" + addr + \" To GO TO is Invalid.\");break;};curr.addGOTO(addr * 3); break; // GOTO 800\n                case \"ADD\": curr.addADD(map(parts[1], varmap), parseInt(parts[2])); break; // ADD A 4\n                case \"SUB\": curr.addSUB(map(parts[1], varmap), parseInt(parts[2])); break; // SUB A 8\n                case \"VAR\": curr.addVAR(map(parts[1], varmap), parseInt(parts[2])); break; // VAR A 2\n                case \"PRINT\": console.log(\"Build Warning:PRINT not supported\");break;\n                case \"HALT\": curr.addHALT();\n                case \"GOTO_IF_ZERO\": curr.addGOTO_IF_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": curr.addGOTO_IF_NOT_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": curr.addVAR(parseInt(parts[1]),parseInt(parts[2])); break; // LOW LEVEL.\n                case \"SHR\": curr.addSHR(map(parts[1],varmap),parseInt(parts[2])); break;\n                case \"SHL\": curr.addSHL(map(parts[1], varmap), parseInt(parts[2])); break;\n                case \"PAUSE\": curr.addPAUSE(parseInt(parts[1])); break;\n                case \"NOP\":curr.addNOP(); break;\n                default:console.log(\"Build Warning: Command \" + (parts[0] || \"EMPTY_STRING\") + \" Not Supported.\"); break;\n            }\n            if (varmap.valuesArray().length > 255) {\n                return {bytecode:[],type:BYTESCRIPT_BYTECODE_SIG};\n            }\n        }\n        console.log(`Build Completed, Build Info: Varibles Used ${varmap.valuesArray().length}/256, ROM used:${Math.roundWithPrecision(((curr.bytecode.length / 1024) / (USE_32KB_ROM ? 32 : 4)) * 100, 4)}% or in alternate format:${curr.bytecode.length / 3}/${USE_32KB_ROM ? \"10,922\" : \"1,365\"} Lines Used. , Asummptions for Size Caluctions: ROM is ${USE_32KB_ROM ? \"32KB\" : \"4KB\"}`)\n        return { bytecode: curr.bytecode, type: BYTESCRIPT_BYTECODE_SIG };\n    }\n    function map(varName: string, map: Map<string, number>) {\n        if (!map.has(varName)) {\n            map.set(varName, map.valuesArray().length == 0 ? 0 : map.valuesArray()[map.valuesArray().length - 1]++); // if it does not exist , make it.\n        }\n        const val = map.get(varName);\n        if (val > 255) {\n            console.log(\"Build Crash:Out of Varibles.\")\n            return null;\n        }\n        return val\n    }\n}","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"bytescript.ts\",\n        \"bytescript.compiler.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756427808389,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><comment x=\"0\" y=\"0\" w=\"340\" h=\"120\">\nconsole.log(\"Starting Execute...\")\n</comment><comment x=\"0\" y=\"0\" w=\"310\" h=\"120\">\nbytescript.runCode({code:prog})\n</comment><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"const prog = `\" line1=\"VAR A 20\" line2=\"SUB A 1\" line3=\"GOTO_IF_NOT_ZERO A 1\" line4=\"PRINT COMPLETED PROGRAM\" line5=\"`\" numlines=\"6\" declaredvars=\"prog\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let bytecode = bytescript.compileCode({ code: prog })\" numlines=\"1\" declaredvars=\"bytecode\"></mutation><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">bytecode.bytecode</field></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"//bytescript.runCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })\nlet DIGIT = 19\nconst prog = `\n  ; Fibonacci(n) with n = 8  => set N to n-1 (here 7) so B = Fib(n) at end\n  VAR A 0        ; first term\n  VAR B 1        ; second term\n  VAR N ${DIGIT-1}        ; steps remaining = n - 1\n  VAR T1 0       ; temp sum A+B\n  VAR T2 0       ; temp buffer for copy\n  ; ---- Loop start: build T1 = A + B (preserve A, B) ----\n  GOTO_IF_ZERO A 14\n  SUB A 1\n ADD T1 1\n ADD T2 1\n GOTO 8\n ; done moving from A into T1, T2 holds a copy of A\n GOTO_IF_ZERO T2 19\n SUB T2 1\n ADD A 1\n GOTO 14\n ; A restored, T2 cleared\n ; copy-add B into T1, preserving B via T2\n GOTO_IF_ZERO B 26\n SUB B 1\n ADD T1 1\n ADD T2 1\n GOTO 20\n ; end B loop\n GOTO_IF_ZERO T2 31\n SUB T2 1\n ADD B 1\n GOTO 26\n ; B restored, T2 cleared, now T1 = A + B\n ; ---- Set A = old B (preserve B) ----\n GOTO_IF_ZERO A 36\n SUB A 1\n GOTO 32\n ; A is zero\n GOTO_IF_ZERO B 42\n SUB B 1\n ADD A 1\n ADD T2 1\n GOTO 36\n ; finished copying B to A, T2 holds old B\n GOTO_IF_ZERO T2 47\n SUB T2 1\n ADD B 1\n GOTO 42\n ; B restored, T2 cleared, A = old B\n ; ---- Set B = T1 (destructive move) ----\n GOTO_IF_ZERO B 52\n SUB B 1\n GOTO 48\n ; B is zero\n GOTO_IF_ZERO T1 56\n SUB T1 1\n ADD B 1\n GOTO 52\n ; B now holds A+B, T1 cleared\n ; ---- Decrement N and loop ----\n SUB N 1\n GOTO_IF_NOT_ZERO N 8\n PRINT  the ${DIGIT}th FIB number is:\n PRINT B\nHALT\n`\n//let bytecode = bytescript.compileCode({ code: prog })\n//console.log(bytecode.bytecode)\nlet start = control.micros();\nconsole.log(\"Starting Execute...\")\nbytescript.runCode({code:prog})\nlet end = control.micros();\nlet time = (end - start) / 1000;\nconsole.log(`TIME TAKEN:${time} milliseconds to calcuate the ${DIGIT}th fibanchi number`)","README.md":"## BYTESCRIPT\r\n\r\nthe imlamton for a basic language called bytescript \r\nbytescript can be: ran via intrupters\r\nor:\r\ncomplied to bytecode \r\nthe bytecode version does not support PRINT ,  reason:\r\n\r\nPRINT would reqiure complex methods to store the string as NOP's or whatever and address matching, etc.\r\nHow Varibles are handled in bytecode: varibles aer assigned a addres of a single byte , taht address refers to the name (diffrent form PRINT , sinc we dont need to know what hte orignal var name was.)","assets.json":"","bytescript.ts":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    function _parseInt(a:string):any {\n        return parseInt(a);\n    }\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let vars:{[index:string]:any} = {\"__complied__\":false};\n        let i = 0;\n        while (i < lines.length) {\n            let line = lines[i].trim().split(\";\")[0] || \"NOP\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = _parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": break; /**  emularion not doable in running. , but not compling. reason: this interfaceswith a specficvaribles address which is the low-leve repsnrentaion of a varible name , example:A = 1 , HELLO_WORLD_THIS_IS_A_SUPER_LONG_VAR_NAME = 2 , note: no longer howl ong th var nam is , the var address is always... a single byte , that menas 256 varibles max. */\n                case \"SHR\": vars[parts[1]] >>= _parseInt(parts[2]); break;\n                case \"SHL\": vars[parts[1]] <<= _parseInt(parts[2]); break;\n                case \"PAUSE\": pause(parseInt(parts[1]) / 50);break // assumes 50khz clock rate for emulation.\n                case \"VADD\": vars[parts[1]] += vars[parts[2]]; break;\n                case \"VSUB\": vars[parts[1]] -= vars[parts[2]]; break;\n                case \"NOP\":break;\n                default: console.log(\"Intrepter Crash: Invalid Command\");return;\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function handle(a: string, b: { [index: string]: any }) {\n        const A_WORD = a.split(\" \")[0]\n        if (!!b[A_WORD]) {\n            return b[A_WORD];\n        } else {\n            return a;\n        }\n    }\n}","bytescript.compiler.ts":"/**\n * The ByteScript Language.\n */\nnamespace bytescript {\n    const USE_32KB_ROM = false;\n    type BYTECODE_TYPE = number;\n    export let BYTECODE_SUPPORTS_PAUSE = true;\n    export const BYTESCRIPT_BYTECODE_SIG = 79489365;\n    interface ByteCode {\n        bytecode: number[];\n        type: BYTECODE_TYPE;\n    }\n    /** For Internal Use Only. */\n    class BYTESCRIPT_COMP {\n        private _nums: number[] = [];\n        constructor() {\n        }\n        get bytecode() {\n            return this._nums;\n        }\n        addGOTO(address: number) {\n            this._nums.push(1)\n            this._nums.push(address & 0xFF);\n            this._nums.push((address >> 8) & 0xFF); // how to?\n        }\n        addADD(varaddress: number, v: number) {\n            this._nums.push(2)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSUB(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addVAR(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addHALT() {\n            this._nums.push(3)\n            this._nums.push(0);\n            this._nums.push(0)\n        }\n        addGOTO_IF_ZERO(varaddress: number, v: number) { \n            this._nums.push(4);\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF);\n        }\n        addGOTO_IF_NOT_ZERO(varaddress: number, v: number) { \n            this._nums.push(5)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addSHR(varaddress:number,v:number) {\n            this._nums.push(6)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addSHL(varaddress: number, v: number) {\n            this._nums.push(7)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addVADD(varA: number, varB: number) {\n            this._nums.push(9)\n            this._nums.push(varA);\n            this._nums.push(varB)\n        }\n        addVSUB(varA: number, varB: number) {\n            this._nums.push(10);\n            this._nums.push(varA);\n            this._nums.push(varB)\n        }\n        addPAUSE(time:number) {\n            // assumption: BYTECODE_SUPPORTS_PAUSE is defined and valid.\n            if (BYTECODE_SUPPORTS_PAUSE) {\n                // supported , allows wait up to 65535 cycles.\n                this._nums.push(8)\n                this._nums.push(time & 0xFF);\n                this._nums.push((time >> 8) & 0xFF);\n            } else {\n                // fallback:NOP train. , only good for few cycle pauses , else... it takes up to much binary size , though this allows any wait time (though it tkaeis up lines of code.)\n                for (let i = 0; i < time; i++) {\n                    this._nums.push(0)\n                    this._nums.push(0)\n                    this._nums.push(0)\n                }\n            }\n        }\n        addNOP() {\n            this._nums.push(0)\n            this._nums.push(0)\n            this._nums.push(0)\n        }\n    }\n    export function compileCode(c: ByteScript): ByteCode {\n        console.log(\"Starting Build...\")\n        let lines = c.code.split(\"\\n\")\n        let varmap = new Map<string, number>();\n        const curr = new BYTESCRIPT_COMP();\n        console.log(\"Initalized Build...\")\n        for (let line of lines) {\n            line = line.trim()\n            line = line.split(\";\")[0];\n            let parts = (line.split(\" \")) || [\"NOP\",\"0\"]\n            if (parts[0] == \"\") continue\n            switch (parts[0]) {\n                case \"GOTO\": let addr = parseInt(parts[1]);if (addr < 0 || addr > lines.length-1) {console.log(\"Build Error: Address \" + addr + \" To GO TO is Invalid.\");break;};curr.addGOTO(addr * 3); break; // GOTO 800\n                case \"ADD\": curr.addADD(map(parts[1], varmap), parseInt(parts[2])); break; // ADD A 4\n                case \"SUB\": curr.addSUB(map(parts[1], varmap), parseInt(parts[2])); break; // SUB A 8\n                case \"VAR\": curr.addVAR(map(parts[1], varmap), parseInt(parts[2])); break; // VAR A 2\n                case \"PRINT\": console.log(\"Build Warning:PRINT not supported\");break;\n                case \"HALT\": curr.addHALT();\n                case \"GOTO_IF_ZERO\": curr.addGOTO_IF_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": curr.addGOTO_IF_NOT_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": curr.addVAR(parseInt(parts[1]),parseInt(parts[2])); break; // LOW LEVEL.\n                case \"SHR\": curr.addSHR(map(parts[1],varmap),parseInt(parts[2])); break;\n                case \"SHL\": curr.addSHL(map(parts[1], varmap), parseInt(parts[2])); break;\n                case \"VADD\": curr.addVADD(map(parts[1], varmap), map(parts[2], varmap)); break;\n                case \"VSUB\": curr.addVSUB(map(parts[1], varmap), map(parts[2], varmap)); break;\n                case \"PAUSE\": curr.addPAUSE(parseInt(parts[1])); break;\n                case \"NOP\":curr.addNOP(); break;\n                default:console.log(\"Build Warning: Command \" + (parts[0] || \"EMPTY_STRING\") + \" Not Supported.\"); break;\n            }\n            if (varmap.valuesArray().length > 255) {\n                return {bytecode:[],type:BYTESCRIPT_BYTECODE_SIG};\n            }\n        }\n        console.log(`Build Completed, Build Info: Varibles Used ${varmap.valuesArray().length}/256, ROM used:${Math.roundWithPrecision(((curr.bytecode.length / 1024) / (USE_32KB_ROM ? 32 : 4)) * 100, 4)}% or in alternate format:${curr.bytecode.length / 3}/${USE_32KB_ROM ? \"10,922\" : \"1,365\"} Lines Used. , Asummptions for Size Caluctions: ROM is ${USE_32KB_ROM ? \"32KB\" : \"4KB\"}`)\n        return { bytecode: curr.bytecode, type: BYTESCRIPT_BYTECODE_SIG };\n    }\n    function map(varName: string, map: Map<string, number>) {\n        if (!map.has(varName)) {\n            map.set(varName, map.valuesArray().length == 0 ? 0 : map.valuesArray()[map.valuesArray().length - 1]++); // if it does not exist , make it.\n        }\n        const val = map.get(varName);\n        if (val > 255) {\n            console.log(\"Build Crash:Out of Varibles.\")\n            return null;\n        }\n        return val\n    }\n}","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"bytescript.ts\",\n        \"bytescript.compiler.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756430121531,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><comment x=\"0\" y=\"0\" w=\"340\" h=\"120\">\nconsole.log(\"Starting Execute...\")\n</comment><comment x=\"0\" y=\"0\" w=\"310\" h=\"120\">\nbytescript.runCode({code:prog})\n</comment><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"const prog = `\" line1=\"VAR A 20\" line2=\"SUB A 1\" line3=\"GOTO_IF_NOT_ZERO A 1\" line4=\"PRINT COMPLETED PROGRAM\" line5=\"`\" numlines=\"6\" declaredvars=\"prog\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let bytecode = bytescript.compileCode({ code: prog })\" numlines=\"1\" declaredvars=\"bytecode\"></mutation><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">bytecode.bytecode</field></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"//bytescript.runCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })\nlet DIGIT = 19\nconst prog = `\n ; Fast Fibonacci with VADD / VSUB\nVAR A 0        ; first term\nVAR B 1        ; second term\nVAR N 31       ; loop count = n - 1 (so Fib(32) at end)\nVAR TMP 0      ; temporary\n\n; ---- Loop start ----\nVAR TMP 0      ; TMP = 0\nVADD TMP A      ; TMP = A\nVADD TMP B     ; TMP = A + B\n\nVAR A 0        ; A = 0\nVADD A B        ; A = old B\n\nVAR B 0        ; B = 0\nVADD B TMP      ; B = sum   (could be VADD B TMP too – both ok here)\n\nSUB N 1        ; N = N - 1\nGOTO_IF_NOT_ZERO N 7\n\nPRINT B\nHALT\n`\n//let bytecode = bytescript.compileCode({ code: prog })\n//console.log(bytecode.bytecode)\nlet start = control.micros();\nconsole.log(\"Starting Execute...\")\nbytescript.runCode({code:prog})\nlet end = control.micros();\nlet time = (end - start) / 1000;\nconsole.log(`TIME TAKEN:${time} milliseconds to calcuate the ${DIGIT}th fibanchi number`)","README.md":"## BYTESCRIPT\r\n\r\nthe imlamton for a basic language called bytescript \r\nbytescript can be: ran via intrupters\r\nor:\r\ncomplied to bytecode \r\nthe bytecode version does not support PRINT ,  reason:\r\n\r\nPRINT would reqiure complex methods to store the string as NOP's or whatever and address matching, etc.\r\nHow Varibles are handled in bytecode: varibles aer assigned a addres of a single byte , taht address refers to the name (diffrent form PRINT , sinc we dont need to know what hte orignal var name was.)","assets.json":"","bytescript.ts":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    function _parseInt(a:string):any {\n        return parseInt(a);\n    }\n    export function preprocess(lines:string[], buildMode = false) {\n        const labelMap = new Map<string,any>();\n        let address = 0;\n\n        // pass 1 — find labels and record their addresses\n        lines.forEach((lineRaw) => {\n            const line = lineRaw.trim();\n\n            // skip label defs in both modes, but record address mapping\n            if (line.endsWith(\":\")) {\n                const label = line.slice(0, -1).trim();\n                labelMap.set(label, address);\n                return;\n            }\n\n            if (buildMode) {\n                // in build mode, comments/blanks don't increment address\n                if (!line || line.startsWith(\";\")) return;\n            }\n\n            // everything else increments address counter\n            address++;\n        });\n\n        // pass 2 — rewrite label references, strip fluff for build\n        const out:string[] = [];\n        lines.forEach(lineRaw => {\n            let line = lineRaw.trim();\n            if (line == \"\" && buildMode) return;                   // skip blanks in build mode\n            if (line.startsWith(\";\")) {           // skip comments in build mode\n                if (buildMode) return;\n            }\n            if (line.endsWith(\":\")) return;       // skip label defs always\n\n            const parts = line.split(\" \");        // plain split, not regex\n            const op = parts[0];\n\n            if (op === \"GOTO\" && labelMap.has(parts[1])) {\n                parts[1] = labelMap.get(parts[1]);\n                line = parts.join(\" \");\n            } else if ((op === \"GOTO_IF_ZERO\" || op === \"GOTO_IF_NOT_ZERO\") &&\n                labelMap.has(parts[2])) {\n                parts[2] = labelMap.get(parts[2]);\n                line = parts.join(\" \");\n            }\n\n            out.push(line);\n        });\n\n        return out;\n    }\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        lines = preprocess(lines,false);\n        let vars:{[index:string]:any} = {\"__complied__\":\"false\"};\n        let i = 0;\n        while (i < lines.length) {\n            let line = lines[i].trim().split(\";\")[0] || \"NOP\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = _parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": break; /**  emularion not doable in running. , but not compling. reason: this interfaceswith a specficvaribles address which is the low-leve repsnrentaion of a varible name , example:A = 1 , HELLO_WORLD_THIS_IS_A_SUPER_LONG_VAR_NAME = 2 , note: no longer howl ong th var nam is , the var address is always... a single byte , that menas 256 varibles max. */\n                case \"SHR\": vars[parts[1]] >>= _parseInt(parts[2]); break;\n                case \"SHL\": vars[parts[1]] <<= _parseInt(parts[2]); break;\n                case \"PAUSE\": pause(parseInt(parts[1]) / 50);break // assumes 50khz clock rate for emulation.\n                case \"VADD\": vars[parts[1]] = (intify(vars[parts[1]]) + intify(vars[parts[2]])); break;\n                case \"VSUB\": vars[parts[1]] = (intify(vars[parts[1]]) - intify(vars[parts[2]])); break;\n                case \"NOP\":break;\n                default: console.log(\"Intrepter Crash: Invalid Command\");return;\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function intify(a:any) {\n        if (typeof a == \"number\") {\n            return a || 0\n        } else {\n            return parseInt(a) || 0\n        }\n    }\n    function handle(a: string, b: { [index: string]: any }) {\n        const A_WORD = a.split(\" \")[0]\n        if (!!b[A_WORD]) {\n            return b[A_WORD];\n        } else {\n            return a;\n        }\n    }\n}","bytescript.compiler.ts":"/**\n * The ByteScript Language.\n */\nnamespace bytescript {\n    const USE_32KB_ROM = false;\n    type BYTECODE_TYPE = number;\n    export let BYTECODE_SUPPORTS_PAUSE = true;\n    export const BYTESCRIPT_BYTECODE_SIG = 79489365;\n    interface ByteCode {\n        bytecode: number[];\n        type: BYTECODE_TYPE;\n    }\n    /** For Internal Use Only. */\n    class BYTESCRIPT_COMP {\n        private _nums: number[] = [];\n        constructor() {\n        }\n        get bytecode() {\n            return this._nums;\n        }\n        addGOTO(address: number) {\n            this._nums.push(1)\n            this._nums.push(address & 0xFF);\n            this._nums.push((address >> 8) & 0xFF); // how to?\n        }\n        addADD(varaddress: number, v: number) {\n            this._nums.push(2)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSUB(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addVAR(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addHALT() {\n            this._nums.push(3)\n            this._nums.push(0);\n            this._nums.push(0)\n        }\n        addGOTO_IF_ZERO(varaddress: number, v: number) { \n            this._nums.push(4);\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF);\n        }\n        addGOTO_IF_NOT_ZERO(varaddress: number, v: number) { \n            this._nums.push(5)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addSHR(varaddress:number,v:number) {\n            this._nums.push(6)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addSHL(varaddress: number, v: number) {\n            this._nums.push(7)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addVADD(varA: number, varB: number) {\n            this._nums.push(9)\n            this._nums.push(varA);\n            this._nums.push(varB)\n        }\n        addVSUB(varA: number, varB: number) {\n            this._nums.push(10);\n            this._nums.push(varA);\n            this._nums.push(varB)\n        }\n        addSig() {\n            const sig = 10058;\n            this._nums.insertAt(0,0);\n            this._nums.insertAt(1,sig & 0xFF);       // low byte\n            this._nums.insertAt(2,(sig >> 8) & 0xFF); // high byte\n        }\n        addPAUSE(time:number) {\n            // assumption: BYTECODE_SUPPORTS_PAUSE is defined and valid.\n            if (BYTECODE_SUPPORTS_PAUSE) {\n                // supported , allows wait up to 65535 cycles.\n                this._nums.push(8)\n                this._nums.push(time & 0xFF);\n                this._nums.push((time >> 8) & 0xFF);\n            } else {\n                // fallback:NOP train. , only good for few cycle pauses , else... it takes up to much binary size , though this allows any wait time (though it tkaeis up lines of code.)\n                for (let i = 0; i < time; i++) {\n                    this._nums.push(0)\n                    this._nums.push(0)\n                    this._nums.push(0)\n                }\n            }\n        }\n        addNOP() {\n            this._nums.push(0)\n            this._nums.push(0)\n            this._nums.push(0)\n        }\n    }\n    export function compileCode(c: ByteScript): ByteCode {\n        console.log(\"Starting Build...\")\n        let lines = c.code.split(\"\\n\")\n        lines = preprocess(lines,true)\n        let varmap = new Map<string, number>();\n        const curr = new BYTESCRIPT_COMP();\n        console.log(\"Initalized Build...\")\n        for (let line of lines) {\n            line = line.trim()\n            line = line.split(\";\")[0];\n            let parts = (line.split(\" \")) || [\"NOP\",\"0\"]\n            if (parts[0] == \"\") continue\n            switch (parts[0]) {\n                case \"GOTO\": let addr = parseInt(parts[1]);if (addr < 0 || addr > lines.length-1) {console.log(\"Build Error: Address \" + addr + \" To GO TO is Invalid.\");break;};curr.addGOTO(addr * 3); break; // GOTO 800\n                case \"ADD\": curr.addADD(map(parts[1], varmap), parseInt(parts[2])); break; // ADD A 4\n                case \"SUB\": curr.addSUB(map(parts[1], varmap), parseInt(parts[2])); break; // SUB A 8\n                case \"VAR\": curr.addVAR(map(parts[1], varmap), parseInt(parts[2])); break; // VAR A 2\n                case \"PRINT\": console.log(\"Build Warning:PRINT not supported\");break;\n                case \"HALT\": curr.addHALT();\n                case \"GOTO_IF_ZERO\": curr.addGOTO_IF_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": curr.addGOTO_IF_NOT_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": curr.addVAR(parseInt(parts[1]),parseInt(parts[2])); break; // LOW LEVEL.\n                case \"SHR\": curr.addSHR(map(parts[1],varmap),parseInt(parts[2])); break;\n                case \"SHL\": curr.addSHL(map(parts[1], varmap), parseInt(parts[2])); break;\n                case \"VADD\": curr.addVADD(map(parts[1], varmap), map(parts[2], varmap)); break;\n                case \"VSUB\": curr.addVSUB(map(parts[1], varmap), map(parts[2], varmap)); break;\n                case \"PAUSE\": curr.addPAUSE(parseInt(parts[1])); break;\n                case \"NOP\":curr.addNOP(); break;\n                default:console.log(\"Build Warning: Command \" + (parts[0] || \"EMPTY_STRING\") + \" Not Supported.\"); break;\n            }\n            if (varmap.valuesArray().length > 255) {\n                return {bytecode:[],type:BYTESCRIPT_BYTECODE_SIG};\n            }\n        }\n        console.log(`Build Completed, Build Info: Varibles Used ${varmap.valuesArray().length}/256, ROM used:${Math.roundWithPrecision(((curr.bytecode.length / 1024) / (USE_32KB_ROM ? 32 : 4)) * 100, 4)}% or in alternate format:${curr.bytecode.length / 3}/${USE_32KB_ROM ? \"10,922\" : \"1,365\"} Lines Used. , Asummptions for Size Caluctions: ROM is ${USE_32KB_ROM ? \"32KB\" : \"4KB\"}`)\n        curr.addSig();\n        return { bytecode: curr.bytecode, type: BYTESCRIPT_BYTECODE_SIG };\n    }\n    function map(varName: string, map: Map<string, number>) {\n        if (!map.has(varName)) {\n            map.set(varName, map.valuesArray().length == 0 ? 0 : map.valuesArray()[map.valuesArray().length - 1]++); // if it does not exist , make it.\n        }\n        const val = map.get(varName);\n        if (val > 255) {\n            console.log(\"Build Crash:Out of Varibles.\")\n            return null;\n        }\n        return val\n    }\n}","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"bytescript.ts\",\n        \"bytescript.compiler.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756432031869,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><comment x=\"0\" y=\"0\" w=\"340\" h=\"120\">\nconsole.log(\"Starting Execute...\")\n</comment><comment x=\"0\" y=\"0\" w=\"310\" h=\"120\">\nbytescript.runCode({code:prog})\n</comment><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"const prog = `\" line1=\"VAR A 20\" line2=\"SUB A 1\" line3=\"GOTO_IF_NOT_ZERO A 1\" line4=\"PRINT COMPLETED PROGRAM\" line5=\"`\" numlines=\"6\" declaredvars=\"prog\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let bytecode = bytescript.compileCode({ code: prog })\" numlines=\"1\" declaredvars=\"bytecode\"></mutation><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">bytecode.bytecode</field></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"//bytescript.runCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })\nlet DIGIT = 19\nconst prog = `\n; Fast Fibonacci with VADD / VSUB and labels\n\nVAR A 0        ; first term\nVAR B 1        ; second term\nVAR N 31       ; loop count = n - 1 (so Fib(32) at end)\nVAR TMP 0      ; temporary\n\n; ---- Loop start ----\nLOOP_START:\n    GOTO STAGE1\nSTAGE1:\n    VAR TMP 0      ; TMP = 0\n    VADD TMP A     ; TMP = A\n    VADD TMP B     ; TMP = A + B\n    GOTO STAGE2\nSTAGE2:\n    VAR A 0        ; A = 0\n    VADD A B       ; A = old B\n\n    VAR B 0        ; B = 0\n    VADD B TMP     ; B = sum\n    GOTO FINISH\nFINISH:\n    SUB N 1        ; N = N - 1\n    GOTO_IF_NOT_ZERO N LOOP_START\n\n    PRINT B\n    HALT           ; stop execution early, even though end of code would stop anyway\n`\n//let bytecode = bytescript.compileCode({ code: prog })\n//console.log(bytecode.bytecode)\nlet start = control.micros();\nconsole.log(\"Starting Execute...\")\nbytescript.runCode({ code: prog })\nlet end = control.micros();\nlet time = (end - start) / 1000;\nconsole.log(`TIME TAKEN:${time} milliseconds to calcuate the ${DIGIT}th fibanchi number`)","README.md":"## BYTESCRIPT\r\n\r\nthe imlamton for a basic language called bytescript \r\nbytescript can be: ran via intrupters\r\nor:\r\ncomplied to bytecode \r\nthe bytecode version does not support PRINT ,  reason:\r\n\r\nPRINT would reqiure complex methods to store the string as NOP's or whatever and address matching, etc.\r\nHow Varibles are handled in bytecode: varibles aer assigned a addres of a single byte , taht address refers to the name (diffrent form PRINT , sinc we dont need to know what hte orignal var name was.)","assets.json":"","bytescript.ts":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    function _parseInt(a:string):any {\n        return parseInt(a);\n    }\n    export function preprocess(lines:string[], buildMode = false) {\n        const labelMap = new Map<string,any>();\n        let address = 0;\n\n        // pass 1 — find labels and record their addresses\n        lines.forEach((lineRaw) => {\n            const line = lineRaw.trim();\n\n            // skip label defs in both modes, but record address mapping\n            if (line.endsWith(\":\")) {\n                const label = line.slice(0, -1).trim();\n                labelMap.set(label, address);\n                return;\n            }\n\n            if (buildMode) {\n                // in build mode, comments/blanks don't increment address\n                if (!line || line.startsWith(\";\")) return;\n            }\n\n            // everything else increments address counter\n            address++;\n        });\n\n        // pass 2 — rewrite label references, strip fluff for build\n        const out:string[] = [];\n        lines.forEach(lineRaw => {\n            let line = lineRaw.trim();\n            if (line == \"\" && buildMode) return;                   // skip blanks in build mode\n            if (line.startsWith(\";\")) {           // skip comments in build mode\n                if (buildMode) return;\n            }\n            if (line.endsWith(\":\")) return;       // skip label defs always\n\n            const parts = line.split(\" \");        // plain split, not regex\n            const op = parts[0];\n\n            if (op === \"GOTO\" && labelMap.has(parts[1])) {\n                parts[1] = labelMap.get(parts[1]);\n                line = parts.join(\" \");\n            } else if ((op === \"GOTO_IF_ZERO\" || op === \"GOTO_IF_NOT_ZERO\") &&\n                labelMap.has(parts[2])) {\n                parts[2] = labelMap.get(parts[2]);\n                line = parts.join(\" \");\n            }\n\n            out.push(line);\n        });\n\n        return out;\n    }\n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        lines = preprocess(lines,false);\n        let vars:{[index:string]:any} = {\"__complied__\":\"false\"};\n        let i = 0;\n        while (i < lines.length) {\n            let line = lines[i].trim().split(\";\")[0] || \"NOP\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = _parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2]; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": break; /**  emularion not doable in running. , but not compling. reason: this interfaceswith a specficvaribles address which is the low-leve repsnrentaion of a varible name , example:A = 1 , HELLO_WORLD_THIS_IS_A_SUPER_LONG_VAR_NAME = 2 , note: no longer howl ong th var nam is , the var address is always... a single byte , that menas 256 varibles max. */\n                case \"SHR\": vars[parts[1]] >>= _parseInt(parts[2]); break;\n                case \"SHL\": vars[parts[1]] <<= _parseInt(parts[2]); break;\n                case \"PAUSE\": pause(parseInt(parts[1]) / 50);break // assumes 50khz clock rate for emulation.\n                case \"VADD\": vars[parts[1]] = (intify(vars[parts[1]]) + intify(vars[parts[2]])); break;\n                case \"VSUB\": vars[parts[1]] = (intify(vars[parts[1]]) - intify(vars[parts[2]])); break;\n                case \"NOP\":break;\n                default: console.log(\"Intrepter Crash: Invalid Command\");return;\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n    }\n    function intify(a:any) {\n        if (typeof a == \"number\") {\n            return a || 0\n        } else {\n            return parseInt(a) || 0\n        }\n    }\n    function handle(a: string, b: { [index: string]: any }) {\n        const A_WORD = a.split(\" \")[0]\n        if (!!b[A_WORD]) {\n            return b[A_WORD];\n        } else {\n            return a;\n        }\n    }\n}","bytescript.compiler.ts":"/**\n * The ByteScript Language.\n */\nnamespace bytescript {\n    const USE_32KB_ROM = false;\n    type BYTECODE_TYPE = number;\n    export let BYTECODE_SUPPORTS_PAUSE = true;\n    export const BYTESCRIPT_BYTECODE_SIG = 79489365;\n    interface ByteCode {\n        bytecode: number[];\n        type: BYTECODE_TYPE;\n    }\n    /** For Internal Use Only. */\n    class BYTESCRIPT_COMP {\n        private _nums: number[] = [];\n        constructor() {\n        }\n        get bytecode() {\n            return this._nums;\n        }\n        addGOTO(address: number) {\n            this._nums.push(1)\n            this._nums.push(address & 0xFF);\n            this._nums.push((address >> 8) & 0xFF); // how to?\n        }\n        addADD(varaddress: number, v: number) {\n            this._nums.push(2)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSUB(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addVAR(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addHALT() {\n            this._nums.push(3)\n            this._nums.push(0);\n            this._nums.push(0)\n        }\n        addGOTO_IF_ZERO(varaddress: number, v: number) { \n            this._nums.push(4);\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF);\n        }\n        addGOTO_IF_NOT_ZERO(varaddress: number, v: number) { \n            this._nums.push(5)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addSHR(varaddress:number,v:number) {\n            this._nums.push(6)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addSHL(varaddress: number, v: number) {\n            this._nums.push(7)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addVADD(varA: number, varB: number) {\n            this._nums.push(9)\n            this._nums.push(varA);\n            this._nums.push(varB)\n        }\n        addVSUB(varA: number, varB: number) {\n            this._nums.push(10);\n            this._nums.push(varA);\n            this._nums.push(varB)\n        }\n        addPRINT(varaddress:number) {\n            this._nums.push(10);\n            this._nums.push(varaddress);\n            this._nums.push(0)\n        }\n        addSig() {\n            const sig = 10058;\n            this._nums.insertAt(0,0);\n            this._nums.insertAt(1,sig & 0xFF);       // low byte\n            this._nums.insertAt(2,(sig >> 8) & 0xFF); // high byte\n        }\n        addPAUSE(time:number) {\n            // assumption: BYTECODE_SUPPORTS_PAUSE is defined and valid.\n            if (BYTECODE_SUPPORTS_PAUSE) {\n                // supported , allows wait up to 65535 cycles.\n                this._nums.push(8)\n                this._nums.push(time & 0xFF);\n                this._nums.push((time >> 8) & 0xFF);\n            } else {\n                // fallback:NOP train. , only good for few cycle pauses , else... it takes up to much binary size , though this allows any wait time (though it tkaeis up lines of code.)\n                for (let i = 0; i < time; i++) {\n                    this._nums.push(0)\n                    this._nums.push(0)\n                    this._nums.push(0)\n                }\n            }\n        }\n        addNOP() {\n            this._nums.push(0)\n            this._nums.push(0)\n            this._nums.push(0)\n        }\n    }\n    export function compileCode(c: ByteScript): ByteCode {\n        console.log(\"Starting Build...\")\n        let lines = c.code.split(\"\\n\")\n        lines = preprocess(lines,true)\n        let varmap = new Map<string, number>();\n        const curr = new BYTESCRIPT_COMP();\n        console.log(\"Initalized Build...\")\n        for (let line of lines) {\n            line = line.trim()\n            line = line.split(\";\")[0];\n            let parts = (line.split(\" \")) || [\"NOP\",\"0\"]\n            if (parts[0] == \"\") continue\n            switch (parts[0]) {\n                case \"GOTO\": let addr = parseInt(parts[1]);if (addr < 0 || addr > lines.length-1) {console.log(\"Build Error: Address \" + addr + \" To GO TO is Invalid.\");break;};curr.addGOTO(addr * 3); break; // GOTO 800\n                case \"ADD\": curr.addADD(map(parts[1], varmap), parseInt(parts[2])); break; // ADD A 4\n                case \"SUB\": curr.addSUB(map(parts[1], varmap), parseInt(parts[2])); break; // SUB A 8\n                case \"VAR\": curr.addVAR(map(parts[1], varmap), parseInt(parts[2])); break; // VAR A 2\n                case \"PRINT\": varmap.has(parts[1]) ? curr.addPRINT(map(parts[1],varmap)): console.log(\"Build Warning:PRINT string not supported\");break;\n                case \"HALT\": curr.addHALT();\n                case \"GOTO_IF_ZERO\": curr.addGOTO_IF_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": curr.addGOTO_IF_NOT_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": curr.addVAR(parseInt(parts[1]),parseInt(parts[2])); break; // LOW LEVEL.\n                case \"SHR\": curr.addSHR(map(parts[1],varmap),parseInt(parts[2])); break;\n                case \"SHL\": curr.addSHL(map(parts[1], varmap), parseInt(parts[2])); break;\n                case \"VADD\": curr.addVADD(map(parts[1], varmap), map(parts[2], varmap)); break;\n                case \"VSUB\": curr.addVSUB(map(parts[1], varmap), map(parts[2], varmap)); break;\n                case \"PAUSE\": curr.addPAUSE(parseInt(parts[1])); break;\n                case \"NOP\":curr.addNOP(); break;\n                default:console.log(\"Build Warning: Command \" + (parts[0] || \"EMPTY_STRING\") + \" Not Supported.\"); break;\n            }\n            if (varmap.valuesArray().length > 255) {\n                return {bytecode:[],type:BYTESCRIPT_BYTECODE_SIG};\n            }\n        }\n        console.log(`Build Completed, Build Info: Varibles Used ${varmap.valuesArray().length}/256, ROM used:${Math.roundWithPrecision(((curr.bytecode.length / 1024) / (USE_32KB_ROM ? 32 : 4)) * 100, 4)}% or in alternate format:${curr.bytecode.length / 3}/${USE_32KB_ROM ? \"10,922\" : \"1,365\"} Lines Used. , Asummptions for Size Caluctions: ROM is ${USE_32KB_ROM ? \"32KB\" : \"4KB\"}`)\n        curr.addSig();\n        return { bytecode: curr.bytecode, type: BYTESCRIPT_BYTECODE_SIG };\n    }\n    function map(varName: string, map: Map<string, number>) {\n        if (!map.has(varName)) {\n            map.set(varName, map.valuesArray().length == 0 ? 0 : map.valuesArray()[map.valuesArray().length - 1]++); // if it does not exist , make it.\n        }\n        const val = map.get(varName);\n        if (val > 255) {\n            console.log(\"Build Crash:Out of Varibles.\")\n            return null;\n        }\n        return val\n    }\n}","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"bytescript.ts\",\n        \"bytescript.compiler.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756433842531,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><comment x=\"0\" y=\"0\" w=\"340\" h=\"120\">\nconsole.log(\"Starting Execute...\")\n</comment><comment x=\"0\" y=\"0\" w=\"310\" h=\"120\">\nbytescript.runCode({code:prog})\n</comment><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"const prog = `\" line1=\"VAR A 20\" line2=\"SUB A 1\" line3=\"GOTO_IF_NOT_ZERO A 1\" line4=\"PRINT COMPLETED PROGRAM\" line5=\"`\" numlines=\"6\" declaredvars=\"prog\"></mutation><next><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"let bytecode = bytescript.compileCode({ code: prog })\" numlines=\"1\" declaredvars=\"bytecode\"></mutation><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">bytecode.bytecode</field></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"//bytescript.runCode({ code: \"PRINT A IS B RIGHT? \\n PRINT CRAZY. \\n PRINT PREP FOR REPITION. \\n GOTO 0\" })\nlet DIGIT = 1\nconst prog = `\n; Fast Fibonacci with VADD / VSUB and labels\n\nVAR A 0        ; first term\nVAR B 1        ; second term\nVAR N ${DIGIT}       ; loop count = n - 1 (so Fib(32) at end)\nVAR TMP 0      ; temporary\n\n; ---- Loop start ----\nLOOP_START:\n    GOTO STAGE1\nSTAGE1:\n    VAR TMP 0      ; TMP = 0\n    VADD TMP A     ; TMP = A\n    VADD TMP B     ; TMP = A + B\n    GOTO STAGE2\nSTAGE2:\n    VAR A 0        ; A = 0\n    VADD A B       ; A = old B\n\n    VAR B 0        ; B = 0\n    VADD B TMP     ; B = sum\n    GOTO FINISH\nFINISH:\n    SUB N 1        ; N = N - 1\n    GOTO_IF_NOT_ZERO N LOOP_START\n\n    PRINT B\n    HALT           ; stop execution early, even though end of code would stop anyway\n`\nfunction log(a:any) {\n    console.log(a);\n    game.showLongText(a,DialogLayout.Full);\n}\n//let bytecode = bytescript.compileCode({ code: prog })\n//console.log(bytecode.bytecode)\nlog(\"Starting Execute...\")\nlet start = control.micros();\nbytescript.runCode({ code: prog })\nlet end = control.micros();\nlet time = (end - start) / 1000;\nlog(`TIME TAKEN:${time} milliseconds to calcuate the ${DIGIT}th fibanchi number`)\n","README.md":"## BYTESCRIPT\r\n\r\nthe imlamton for a basic language called bytescript \r\nbytescript can be: ran via intrupters\r\nor:\r\ncomplied to bytecode \r\nthe bytecode version does not support PRINT ,  reason:\r\n\r\nPRINT would reqiure complex methods to store the string as NOP's or whatever and address matching, etc.\r\nHow Varibles are handled in bytecode: varibles aer assigned a addres of a single byte , taht address refers to the name (diffrent form PRINT , sinc we dont need to know what hte orignal var name was.)","assets.json":"","bytescript.ts":"interface ByteScript {\n    code:string;\n    name?:string;\n}\n\nnamespace bytescript {\n    function _parseInt(a:string):any {\n        return parseInt(a);\n    }\n    export function preprocess(lines:string[], buildMode = false) {\n        const labelMap = new Map<string,any>();\n        let address = 0;\n\n        // pass 1 — find labels and record their addresses\n        lines.forEach((lineRaw) => {\n            const line = lineRaw.trim();\n\n            // skip label defs in both modes, but record address mapping\n            if (line.endsWith(\":\")) {\n                const label = line.slice(0, -1).trim();\n                labelMap.set(label, address);\n                return;\n            }\n\n            if (buildMode) {\n                // in build mode, comments/blanks don't increment address\n                if (!line || line.startsWith(\";\")) return;\n            }\n\n            // everything else increments address counter\n            address++;\n        });\n\n        // pass 2 — rewrite label references, strip fluff for build\n        const out:string[] = [];\n        lines.forEach(lineRaw => {\n            let line = lineRaw.trim();\n            if (line == \"\" && buildMode) return;                   // skip blanks in build mode\n            if (line.startsWith(\";\")) {           // skip comments in build mode\n                if (buildMode) return;\n            }\n            if (line.endsWith(\":\")) return;       // skip label defs always\n\n            const parts = line.split(\" \");        // plain split, not regex\n            const op = parts[0];\n\n            if (op === \"GOTO\" && labelMap.has(parts[1])) {\n                parts[1] = labelMap.get(parts[1]);\n                line = parts.join(\" \");\n            } else if ((op === \"GOTO_IF_ZERO\" || op === \"GOTO_IF_NOT_ZERO\") &&\n                labelMap.has(parts[2])) {\n                parts[2] = labelMap.get(parts[2]);\n                line = parts.join(\" \");\n            }\n\n            out.push(line);\n        });\n\n        return out;\n    }\n    function splitParts(line: string): string[] {\n        return line.trim().split(\" \").filter(p => p.length > 0);\n    }\n\n    function isNumberToken(tok: string): boolean {\n        // Simple numeric check for pre-preprocessing stage\n        for (let i = 0; i < tok.length; i++) {\n            const c = tok.charCodeAt(i);\n            if (c < 48 || c > 57) return false;\n        }\n        return tok.length > 0;\n    }\n\n    function inlineSingleUseLabels(lines: string[]): string[] {\n        // Arrays for labels and refs\n        let labelNames: string[] = [];\n        let labelPositions: number[] = [];\n        let refLabels: string[] = [];\n\n        // Pass 1 – collect labels\n        for (let i = 0; i < lines.length; i++) {\n            let t = lines[i].trim();\n            if (t && t.charAt(t.length - 1) === \":\") {\n                labelNames.push(t.slice(0, t.length - 1));\n                labelPositions.push(i);\n            }\n        }\n\n        // Pass 2 – collect refs from GOTOs\n        for (let i = 0; i < lines.length; i++) {\n            let parts = lines[i].trim().split(\" \");\n            if (parts[0] === \"GOTO\" && parts.length >= 2 && isNaN(parseInt(parts[1]))) {\n                refLabels.push(parts[1]);\n            }\n        }\n\n        // Pass 3 – inline labels that appear exactly once\n        let output: string[] = [];\n        for (let i = 0; i < lines.length; i++) {\n            let parts = lines[i].trim().split(\" \");\n            if (parts[0] === \"GOTO\") {\n                let idx = refLabels.indexOf(parts[1]);\n                if (idx !== -1 && refLabels.lastIndexOf(parts[1]) === idx) {\n                    // Find label position\n                    let labelIdx = labelNames.indexOf(parts[1]);\n                    if (labelIdx !== -1) {\n                        let start = labelPositions[labelIdx] + 1;\n                        let end = start;\n                        while (end < lines.length && lines[end].trim().charAt(lines[end].trim().length - 1) !== \":\") {\n                            end++;\n                        }\n                        output.push(\"; Inlined from \" + parts[1]);\n                        for (let j = start; j < end; j++) {\n                            output.push(lines[j]);\n                        }\n                        continue; // skip pushing the GOTO itself\n                    }\n                }\n            }\n            // Default: push the original line\n            output.push(lines[i]);\n        }\n        return output;\n    }\n    \n    export function runCode(c:ByteScript) {\n        let lines = c.code.split(\"\\n\");\n        let lram = Buffer.create(256);\n        let varmap:Map<string,number> = new Map()\n        lines = preprocess(lines,false);\n        let vars:{[index:string]:any} = {\"__complied__\":\"false\"};\n        let i = 0;\n        let counter = 0;\n        while (i < lines.length) {\n            let line = lines[i].trim().split(\";\")[0] || \"NOP\";\n            let parts = line.split(\" \");\n            switch (parts[0]) {\n                case \"GOTO\": i = _parseInt(parts[1]) - 1; break; // GOTO 800\n                case \"ADD\": vars[parts[1]] += parseInt(parts[2]); break; // ADD A 4\n                case \"SUB\": vars[parts[1]] -= parseInt(parts[2]); break; // SUB A 8\n                case \"VAR\": vars[parts[1]] = parts[2];if (!varmap.has(parts[1])) {varmap.set(parts[1],counter++)}; break; // VAR A 2\n                case \"PRINT\":console.log(`PRINT:${handle(parts.slice(1).join(' '),vars)}`); break; // PRINT SOME_VAR/VALUE,  NOT SUPPORTED IN BYTECODE.\n                case \"HALT\": return; break; // HALT\n                case \"GOTO_IF_ZERO\": vars[parts[1]] == 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": vars[parts[1]] !== 0 ? i = (_parseInt(parts[2]) - 1) : 0; break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": {\n                    // parts[1] = numeric var address (low-level slot ID)\n                    // parts[2] = value to store\n\n                    const slotAddr = parseInt(parts[1]);\n                    const value = parseInt(parts[2]);\n\n                    // Reverse-lookup: find which key(s) map to this slotAddr\n                    const keys = findKeyByValue<string,number>(varmap, slotAddr);\n\n                    if (keys.length > 0) {\n                        const varName = keys[0]; // assuming unique slot addresses\n                        // Now actually perform the store in your source-VM state\n                        vars[varName] = value;\n                    } else {\n                        console.log(\"Intrepter Crash: Invalid Address.\")\n                        break;\n                    }\n                    break;\n                }\n                case \"SHR\": vars[parts[1]] >>= _parseInt(parts[2]); break;\n                case \"SHL\": vars[parts[1]] <<= _parseInt(parts[2]); break;\n                case \"PAUSE\": pause(parseInt(parts[1]) / 50);break // assumes 50khz clock rate for emulation.\n                case \"VADD\": vars[parts[1]] = (intify(vars[parts[1]]) + intify(vars[parts[2]])); break;\n                case \"VSUB\": vars[parts[1]] = (intify(vars[parts[1]]) - intify(vars[parts[2]])); break;\n                case \"LRD\": lram.setUint8(parseInt(parts[1]),parseInt(parts[2]));break;\n                case \"LWR\": vars[findKeyByValue<string,number>(varmap,parseInt(parts[2]))[0]] = lram.getUint8(parseInt(parts[1]));break;\n                case \"NOP\":break;\n                default: console.log(\"Intrepter Crash: Invalid Command\");return;\n            }\n            i++; // INCREMENT.\n        }\n        vars = {};\n        lram.fill(0);\n    }\n    function intify(a:any) {\n        if (typeof a == \"number\") {\n            return a || 0\n        } else {\n            return parseInt(a) || 0\n        }\n    }\n    function handle(a: string, b: { [index: string]: any }) {\n        const A_WORD = a.split(\" \")[0]\n        if (!!b[A_WORD]) {\n            return b[A_WORD];\n        } else {\n            return a;\n        }\n    }\n    function findKeyByValue<K, V>(map: Map<K, V>, searchValue: V): K[] {\n        const result: K[] = [];\n        const vals = map.valuesArray();\n        const keys = map.keysArray();\n\n        for (let i = 0; i < vals.length; i++) {\n            if (vals[i] === searchValue) {\n                result.push(keys[i]);\n            }\n        }\n        return result;\n\n    }\n}","bytescript.compiler.ts":"/**\n * The ByteScript Language.\n */\nnamespace bytescript {\n    const USE_32KB_ROM = false;\n    type BYTECODE_TYPE = number;\n    export let BYTECODE_SUPPORTS_PAUSE = true;\n    export const BYTESCRIPT_BYTECODE_SIG = 79489365;\n    interface ByteCode {\n        bytecode: number[];\n        type: BYTECODE_TYPE;\n    }\n    /** For Internal Use Only. */\n    class BYTESCRIPT_COMP {\n        private _nums: number[] = [];\n        constructor() {\n        }\n        get bytecode() {\n            return this._nums;\n        }\n        addGOTO(address: number) {\n            this._nums.push(1)\n            this._nums.push(address & 0xFF);\n            this._nums.push((address >> 8) & 0xFF); // how to?\n        }\n        addADD(varaddress: number, v: number) {\n            this._nums.push(2)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addSUB(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addVAR(varaddress: number, v: number) {\n            this._nums.push(3)\n            this._nums.push(varaddress);\n            this._nums.push(v)\n        }\n        addLRD(address:number,value:number) {\n            this._nums.push(12)\n            this._nums.push(address)\n            this._nums.push(value)\n        }\n        addLWR(address: number, varaddress: number) {\n            this._nums.push(13)\n            this._nums.push(address)\n            this._nums.push(varaddress)\n        }\n        addHALT() {\n            this._nums.push(3)\n            this._nums.push(0);\n            this._nums.push(0)\n        }\n        addGOTO_IF_ZERO(varaddress: number, v: number) { \n            this._nums.push(4);\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF);\n        }\n        addGOTO_IF_NOT_ZERO(varaddress: number, v: number) { \n            this._nums.push(5)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addSHR(varaddress:number,v:number) {\n            this._nums.push(6)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addSHL(varaddress: number, v: number) {\n            this._nums.push(7)\n            this._nums.push(varaddress);\n            this._nums.push(v & 0xFF)\n        }\n        addVADD(varA: number, varB: number) {\n            this._nums.push(9)\n            this._nums.push(varA);\n            this._nums.push(varB)\n        }\n        addVSUB(varA: number, varB: number) {\n            this._nums.push(10);\n            this._nums.push(varA);\n            this._nums.push(varB)\n        }\n        addPRINT(varaddress:number) {\n            this._nums.push(11);\n            this._nums.push(varaddress);\n            this._nums.push(0)\n        }\n        addSig() {\n            const sig = 10058;\n            this._nums.insertAt(0,0);\n            this._nums.insertAt(1,sig & 0xFF);       // low byte\n            this._nums.insertAt(2,(sig >> 8) & 0xFF); // high byte\n        }\n        addPAUSE(time:number) {\n            // assumption: BYTECODE_SUPPORTS_PAUSE is defined and valid.\n            if (BYTECODE_SUPPORTS_PAUSE) {\n                // supported , allows wait up to 65535 cycles.\n                this._nums.push(8)\n                this._nums.push(time & 0xFF);\n                this._nums.push((time >> 8) & 0xFF);\n            } else {\n                // fallback:NOP train. , only good for few cycle pauses , else... it takes up to much binary size , though this allows any wait time (though it tkaeis up lines of code.)\n                for (let i = 0; i < time; i++) {\n                    this._nums.push(0)\n                    this._nums.push(0)\n                    this._nums.push(0)\n                }\n            }\n        }\n        addNOP() {\n            this._nums.push(0)\n            this._nums.push(0)\n            this._nums.push(0)\n        }\n    }\n    export function compileCode(c: ByteScript): ByteCode {\n        console.log(\"Starting Build...\")\n        let lines = c.code.split(\"\\n\")\n        lines = preprocess(lines,true)\n        let varmap = new Map<string, number>();\n        const curr = new BYTESCRIPT_COMP();\n        console.log(\"Initalized Build...\")\n        for (let line of lines) {\n            line = line.trim()\n            line = line.split(\";\")[0];\n            let parts = (line.split(\" \")) || [\"NOP\",\"0\"]\n            if (parts[0] == \"\") continue\n            switch (parts[0]) {\n                case \"GOTO\": let addr = parseInt(parts[1]);if (addr < 0 || addr > lines.length-1) {console.log(\"Build Error: Address \" + addr + \" To GO TO is Invalid.\");break;};curr.addGOTO(addr * 3); break; // GOTO 800\n                case \"ADD\": curr.addADD(map(parts[1], varmap), parseInt(parts[2])); break; // ADD A 4\n                case \"SUB\": curr.addSUB(map(parts[1], varmap), parseInt(parts[2])); break; // SUB A 8\n                case \"VAR\": curr.addVAR(map(parts[1], varmap), parseInt(parts[2])); break; // VAR A 2\n                case \"PRINT\": varmap.has(parts[1]) ? curr.addPRINT(map(parts[1],varmap)): console.log(\"Build Warning:PRINT string not supported\");break;\n                case \"HALT\": curr.addHALT();\n                case \"GOTO_IF_ZERO\": curr.addGOTO_IF_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_ZERO SOME_VAR SOME_LOCATION\n                case \"GOTO_IF_NOT_ZERO\": curr.addGOTO_IF_NOT_ZERO(map(parts[1], varmap), parseInt(parts[2])); break; // GOTO_IF_NOT_ZERO SOME_VAR SOME_LOCATION\n                case \"MEM_STORE\": curr.addVAR(parseInt(parts[1]),parseInt(parts[2])); break; // LOW LEVEL.\n                case \"SHR\": curr.addSHR(map(parts[1],varmap),parseInt(parts[2])); break;\n                case \"SHL\": curr.addSHL(map(parts[1], varmap), parseInt(parts[2])); break;\n                case \"VADD\": curr.addVADD(map(parts[1], varmap), map(parts[2], varmap)); break;\n                case \"VSUB\": curr.addVSUB(map(parts[1], varmap), map(parts[2], varmap)); break;\n                case \"PAUSE\": curr.addPAUSE(parseInt(parts[1])); break;\n                case \"LRD\":  curr.addLRD(parseInt(parts[1]),parseInt(parts[2])); break;\n                case \"LWR\": curr.addLWR(parseInt(parts[1]), map(parts[2],varmap)); break;\n                case \"NOP\":curr.addNOP(); break;\n                default:console.log(\"Build Warning: Command \" + (parts[0] || \"EMPTY_STRING\") + \" Not Supported.\"); break;\n            }\n            if (varmap.valuesArray().length > 255) {\n                return {bytecode:[],type:BYTESCRIPT_BYTECODE_SIG};\n            }\n        }\n        console.log(`Build Completed, Build Info: Varibles Used ${varmap.valuesArray().length}/256, ROM used:${Math.roundWithPrecision(((curr.bytecode.length / 1024) / (USE_32KB_ROM ? 32 : 4)) * 100, 4)}% or in alternate format:${curr.bytecode.length / 3}/${USE_32KB_ROM ? \"10,922\" : \"1,365\"} Lines Used. , Asummptions for Size Caluctions: ROM is ${USE_32KB_ROM ? \"32KB\" : \"4KB\"}`)\n        curr.addSig();\n        return { bytecode: curr.bytecode, type: BYTESCRIPT_BYTECODE_SIG };\n    }\n    function map(varName: string, map: Map<string, number>) {\n        if (!map.has(varName)) {\n            map.set(varName, map.valuesArray().length == 0 ? 0 : map.valuesArray()[map.valuesArray().length - 1]++); // if it does not exist , make it.\n        }\n        const val = map.get(varName);\n        if (val > 255) {\n            console.log(\"Build Crash:Out of Varibles.\")\n            return null;\n        }\n        return val\n    }\n}","pxt.json":"{\n    \"name\": \"CLBC\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"Promise<somehting>\": \"workspace:2da7244f-461a-41b8-3361-81237d8dceed\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"bytescript.ts\",\n        \"bytescript.compiler.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1756434413857}